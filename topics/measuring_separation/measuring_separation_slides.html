<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Measuring Separation</title>
    
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            overflow: hidden;
        }

        .presentation {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide {
            display: none;
            width: 85vw;
            max-width: 1000px;
            height: 75vh;
            background: white;
            border-radius: 4px;
            padding: 30px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            overflow-y: auto;
            position: absolute;
        }

        .slide.active {
            display: block;
            position: relative;
        }

        /* Typography */
        h1 {
            font-size: 2.2rem;
            font-weight: 300;
            color: #2c3e50;
            margin-bottom: 1.2rem;
            line-height: 1.2;
        }

        h2 {
            font-size: 1.7rem;
            font-weight: 300;
            color: #2c3e50;
            margin-bottom: 1.2rem;
            line-height: 1.3;
        }

        h3 {
            font-size: 1.2rem;
            font-weight: 400;
            color: #34495e;
            margin-bottom: 0.8rem;
        }

        h4 {
            font-size: 1rem;
            font-weight: 500;
            color: #34495e;
            margin-bottom: 0.5rem;
        }

        p {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #5a6c7d;
            margin-bottom: 1rem;
        }

        ul {
            list-style: none;
            margin-bottom: 1rem;
        }

        li {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #5a6c7d;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
            position: relative;
        }

        li::before {
            content: "•";
            color: #3498db;
            position: absolute;
            left: 0;
            font-size: 1.2rem;
        }

        /* Layout classes */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: start;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            align-items: start;
        }

        /* Content blocks */
        .concept-box {
            background: #f8f9fa;
            padding: 1.2rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid #95a5a6;
        }

        .formula-section {
            background: #fdfdfd;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
        }

        .method-box {
            background: #f8f9fa;
            padding: 1.2rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid #3498db;
        }

        /* Title slide styling */
        .title-slide {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .title-slide h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 1.3rem;
            color: #7f8c8d;
            margin-bottom: 2rem;
        }

        .objectives {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .objective {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }

        .objective h3 {
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        /* Comparison layouts */
        .comparison-layout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 2rem;
            align-items: center;
            margin: 2rem 0;
        }

        .metric-box {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 4px;
            text-align: center;
            border: 2px solid #bdc3c7;
        }

        .versus {
            font-size: 1.5rem;
            font-weight: bold;
            color: #34495e;
        }

        /* Dimension comparison */
        .dimension-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .dimension-box {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            border-left: 4px solid #9b59b6;
        }

        /* Algorithm boxes */
        .algorithm-steps {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid #27ae60;
        }

        /* Visualization */
        .viz {
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            padding: 0.8rem;
            margin: 0.8rem 0;
            background: white;
            min-height: 250px;
        }

        /* Navigation */
        .counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #34495e;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        .nav-button {
            position: fixed;
            bottom: 20px;
            background: #34495e;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-button:hover {
            background: #2c3e50;
        }

        .prev {
            left: 20px;
        }

        .next {
            left: 80px;
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Title -->
        <div class="slide active title-slide" id="slide1">
            <h1>Measuring Separation</h1>
            <p class="subtitle">Quantifying Class Boundaries and Cluster Quality</p>
            
            <div class="objectives">
                <div class="objective">
                    <h3>Distance Metrics</h3>
                    <p>Learn center distances, outlier measures, and robust metrics</p>
                </div>
                <div class="objective">
                    <h3>Linear Discriminant Analysis</h3>
                    <p>Master optimal projection for maximum class separation</p>
                </div>
                <div class="objective">
                    <h3>Statistical Measures</h3>
                    <p>Understand scatter matrices and Fisher discriminant ratios</p>
                </div>
                <div class="objective">
                    <h3>High-Dimensional Effects</h3>
                    <p>Discover how separation behaves in high-dimensional spaces</p>
                </div>
            </div>
        </div>

        <!-- Slide 2: What is Separation? -->
        <div class="slide" id="slide2">
            <h2>What is Separation?</h2>
            
            <div class="concept-box">
                <p><strong>Separation measures how well we can distinguish between different classes or clusters in our data.</strong> Good separation means classes are far apart and tightly grouped internally.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Key Separation Concepts</h3>
                    <ul>
                        <li><strong>Between-class distance:</strong> How far apart are class centers?</li>
                        <li><strong>Within-class spread:</strong> How tightly clustered is each class?</li>
                        <li><strong>Overlap:</strong> Do classes share the same regions?</li>
                        <li><strong>Margin:</strong> What's the gap between closest points?</li>
                    </ul>
                    
                    <h3>Why Separation Matters</h3>
                    <ul>
                        <li>Predicts classification accuracy</li>
                        <li>Guides feature selection</li>
                        <li>Determines optimal projections</li>
                        <li>Validates clustering quality</li>
                    </ul>
                </div>
                
                <div>
                    <div class="viz" id="separation-concept-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 3: Distance from Centers -->
        <div class="slide" id="slide3">
            <h2>Distance from Centers</h2>
            
            <div class="concept-box">
                <p><strong>The simplest separation measure:</strong> Calculate distances between class centers and compare to within-class spreads.</p>
            </div>
            
            <div class="comparison-layout">
                <div class="metric-box">
                    <h3>Euclidean Distance</h3>
                    <p>$$d = ||\mu_1 - \mu_2||_2$$</p>
                    <p>Simple, assumes spherical clusters</p>
                </div>
                
                <div class="versus">VS</div>
                
                <div class="metric-box">
                    <h3>Mahalanobis Distance</h3>
                    <p>$$d = \sqrt{(\mu_1 - \mu_2)^T \Sigma^{-1} (\mu_1 - \mu_2)}$$</p>
                    <p>Accounts for covariance structure</p>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>When Center Distance Works</h3>
                    <ul>
                        <li>Classes have similar covariance</li>
                        <li>Gaussian-like distributions</li>
                        <li>Similar cluster sizes</li>
                        <li>Low to moderate dimensions</li>
                    </ul>
                    
                    <h3>Limitations</h3>
                    <ul>
                        <li>Ignores within-class variation</li>
                        <li>Sensitive to outliers in means</li>
                        <li>Assumes convex clusters</li>
                        <li>No information about overlap</li>
                    </ul>
                </div>
                
                <div>
                    <div class="viz" id="center-distance-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Outlier-Aware Measures -->
        <div class="slide" id="slide4">
            <h2>Distance from Outliers</h2>
            
            <div class="concept-box">
                <p><strong>Outliers can drastically affect separation measures.</strong> Robust methods focus on typical points rather than extremes.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Outlier Detection Methods</h3>
                    <ul>
                        <li><strong>Distance-based:</strong> Points far from center</li>
                        <li><strong>Density-based:</strong> Points in low-density regions</li>
                        <li><strong>Statistical:</strong> Beyond standard deviations</li>
                        <li><strong>Isolation-based:</strong> Easy to separate</li>
                    </ul>
                    
                    <div class="method-box">
                        <h4>Robust Separation Formula</h4>
                        <p>$$\text{Robust Distance} = ||\text{median}_1 - \text{median}_2||$$</p>
                        <p>Use trimmed means or medians instead of full means</p>
                    </div>
                </div>
                
                <div>
                    <h3>Impact on Separation</h3>
                    <ul>
                        <li><strong>Outliers inflate distances:</strong> Make separation appear better</li>
                        <li><strong>Skew class centers:</strong> Move away from typical points</li>
                        <li><strong>Increase variance:</strong> Make classes appear less compact</li>
                        <li><strong>Affect boundaries:</strong> Change optimal decision surfaces</li>
                    </ul>
                    
                    <div class="viz" id="outlier-impact-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Linear Discriminant Analysis -->
        <div class="slide" id="slide5">
            <h2>Linear Discriminant Analysis (LDA)</h2>
            
            <div class="concept-box">
                <p><strong>LDA finds the optimal linear projection that maximizes separation between classes.</strong> It's the gold standard for measuring linear separability.</p>
            </div>
            
            <div class="formula-section">
                <h3>Fisher's Linear Discriminant</h3>
                <p>$$J(w) = \frac{w^T S_B w}{w^T S_W w}$$</p>
                <p>Maximize between-class scatter $S_B$, minimize within-class scatter $S_W$</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Scatter Matrices</h3>
                    <div class="algorithm-steps">
                        <h4>Between-class scatter:</h4>
                        <p>$$S_B = \sum_{i=1}^{c} N_i (\mu_i - \mu)(\mu_i - \mu)^T$$</p>
                        
                        <h4>Within-class scatter:</h4>
                        <p>$$S_W = \sum_{i=1}^{c} \sum_{x \in C_i} (x - \mu_i)(x - \mu_i)^T$$</p>
                        
                        <h4>Optimal projection:</h4>
                        <p>$$w^* = S_W^{-1}(\mu_1 - \mu_2)$$</p>
                    </div>
                </div>
                
                <div>
                    <h3>LDA vs PCA</h3>
                    <ul>
                        <li><strong>LDA:</strong> Maximizes class separation</li>
                        <li><strong>PCA:</strong> Maximizes overall variance</li>
                        <li><strong>LDA:</strong> Supervised (uses labels)</li>
                        <li><strong>PCA:</strong> Unsupervised (ignores labels)</li>
                        <li><strong>LDA:</strong> At most C-1 dimensions</li>
                        <li><strong>PCA:</strong> Up to original dimensions</li>
                    </ul>
                    
                    <div class="viz" id="lda-comparison-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Statistical Separation Measures -->
        <div class="slide" id="slide6">
            <h2>Statistical Separation Measures</h2>
            
            <div class="grid-3">
                <div>
                    <h3>Fisher Discriminant Ratio</h3>
                    <div class="method-box">
                        <p>$$F = \frac{(\mu_1 - \mu_2)^2}{\sigma_1^2 + \sigma_2^2}$$</p>
                        <p>Ratio of between-class to within-class variance</p>
                    </div>
                </div>
                
                <div>
                    <h3>Silhouette Coefficient</h3>
                    <div class="method-box">
                        <p>$$s = \frac{b - a}{\max(a, b)}$$</p>
                        <p>Compares within-cluster to nearest-cluster distance</p>
                    </div>
                </div>
                
                <div>
                    <h3>Davies-Bouldin Index</h3>
                    <div class="method-box">
                        <p>$$DB = \frac{1}{n} \sum_{i=1}^{n} \max_{j \neq i} \frac{\sigma_i + \sigma_j}{d(c_i, c_j)}$$</p>
                        <p>Lower values indicate better separation</p>
                    </div>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Calinski-Harabasz Index</h3>
                    <ul>
                        <li>Ratio of between-cluster to within-cluster variance</li>
                        <li>Higher values indicate better clustering</li>
                        <li>Also called variance ratio criterion</li>
                        <li>Good for convex, well-separated clusters</li>
                    </ul>
                    
                    <h3>Dunn Index</h3>
                    <ul>
                        <li>Ratio of minimum inter-cluster to maximum intra-cluster distance</li>
                        <li>Favors compact, well-separated clusters</li>
                        <li>Sensitive to outliers</li>
                        <li>Computationally expensive for large datasets</li>
                    </ul>
                </div>
                
                <div>
                    <div class="viz" id="statistical-measures-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 7: High-Dimensional Separation -->
        <div class="slide" id="slide7">
            <h2>High-Dimensional Separation</h2>
            
            <div class="concept-box">
                <p><strong>Warning:</strong> Separation behaves very differently in high dimensions. Many intuitive measures break down completely.</p>
            </div>
            
            <div class="dimension-comparison">
                <div class="dimension-box">
                    <h4>Low Dimensions (2-10)</h4>
                    <ul>
                        <li>Intuitive distance measures work</li>
                        <li>Visualization possible</li>
                        <li>Clear boundaries exist</li>
                    </ul>
                </div>
                
                <div class="dimension-box">
                    <h4>Medium Dimensions (10-100)</h4>
                    <ul>
                        <li>Distance concentration begins</li>
                        <li>Outliers become more common</li>
                        <li>Projection methods helpful</li>
                    </ul>
                </div>
                
                <div class="dimension-box">
                    <h4>High Dimensions (100+)</h4>
                    <ul>
                        <li>All distances become similar</li>
                        <li>Empty space phenomenon</li>
                        <li>Standard metrics fail</li>
                    </ul>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>The Curse of Dimensionality</h3>
                    <ul>
                        <li><strong>Distance concentration:</strong> All points equidistant</li>
                        <li><strong>Empty space:</strong> Data lives on surface of hypersphere</li>
                        <li><strong>Nearest neighbors:</strong> Become meaningless</li>
                        <li><strong>Volume effects:</strong> Exponential space growth</li>
                    </ul>
                    
                    <div class="method-box">
                        <h4>High-Dimensional Solutions</h4>
                        <ul>
                            <li>Dimensionality reduction (PCA, LDA)</li>
                            <li>Feature selection</li>
                            <li>Specialized distance metrics</li>
                            <li>Subspace clustering</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <div class="viz" id="high-dimensional-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Advanced Separation Metrics -->
        <div class="slide" id="slide8">
            <h2>Advanced Separation Metrics</h2>
            
            <div class="grid-2">
                <div>
                    <h3>Non-Linear Measures</h3>
                    <ul>
                        <li><strong>Kernel methods:</strong> Map to higher-dimensional space</li>
                        <li><strong>Manifold distances:</strong> Follow data structure</li>
                        <li><strong>Graph-based:</strong> Use connectivity information</li>
                        <li><strong>Topological:</strong> Persistent homology</li>
                    </ul>
                    
                    <h3>Context-Aware Metrics</h3>
                    <ul>
                        <li><strong>Local separation:</strong> Neighborhood-based measures</li>
                        <li><strong>Multi-scale:</strong> Different resolutions</li>
                        <li><strong>Adaptive:</strong> Learn optimal distance function</li>
                        <li><strong>Task-specific:</strong> Optimize for end goal</li>
                    </ul>
                </div>
                
                <div>
                    <h3>Practical Considerations</h3>
                    <ul>
                        <li><strong>Computational cost:</strong> Some metrics are expensive</li>
                        <li><strong>Interpretability:</strong> Complex measures hard to understand</li>
                        <li><strong>Robustness:</strong> Sensitivity to noise and outliers</li>
                        <li><strong>Scalability:</strong> Behavior with large datasets</li>
                    </ul>
                    
                    <div class="method-box">
                        <h4>Choosing the Right Metric</h4>
                        <ul>
                            <li>Consider data dimensionality</li>
                            <li>Account for noise levels</li>
                            <li>Match to problem structure</li>
                            <li>Validate with domain knowledge</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="viz" id="advanced-metrics-viz"></div>
        </div>

        <!-- Slide 9: Practical Guidelines -->
        <div class="slide" id="slide9">
            <h2>Practical Guidelines</h2>
            
            <div class="grid-2">
                <div>
                    <h3>When to Use Each Method</h3>
                    <div class="algorithm-steps">
                        <h4>Low dimensions (< 10):</h4>
                        <ul>
                            <li>Euclidean distance between centers</li>
                            <li>Visual inspection</li>
                            <li>Simple scatter ratios</li>
                        </ul>
                        
                        <h4>Medium dimensions (10-100):</h4>
                        <ul>
                            <li>LDA for optimal projection</li>
                            <li>Mahalanobis distance</li>
                            <li>Statistical indices</li>
                        </ul>
                        
                        <h4>High dimensions (100+):</h4>
                        <ul>
                            <li>Dimensionality reduction first</li>
                            <li>Subspace methods</li>
                            <li>Robust measures</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3>Common Pitfalls</h3>
                    <ul>
                        <li><strong>Ignoring dimensionality:</strong> Using low-D intuition in high-D</li>
                        <li><strong>Outlier sensitivity:</strong> Not accounting for extreme points</li>
                        <li><strong>Scale issues:</strong> Features with different units</li>
                        <li><strong>Sample size:</strong> Insufficient data for reliable estimates</li>
                    </ul>
                    
                    <h3>Best Practices</h3>
                    <ul>
                        <li>Always visualize when possible</li>
                        <li>Use multiple complementary measures</li>
                        <li>Validate with cross-validation</li>
                        <li>Consider computational constraints</li>
                        <li>Test robustness with noise</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 10: Key Takeaways -->
        <div class="slide" id="slide10">
            <h2>Key Takeaways</h2>
            
            <div class="concept-box">
                <p><strong>Separation measurement is both fundamental and nuanced.</strong> The right approach depends on your data's characteristics, dimensions, and intended use.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Core Principles</h3>
                    <ul>
                        <li><strong>Multiple measures:</strong> No single metric tells the whole story</li>
                        <li><strong>Dimensionality matters:</strong> High dimensions change everything</li>
                        <li><strong>Context is key:</strong> Choose methods that match your problem</li>
                        <li><strong>Outliers impact:</strong> Use robust measures when needed</li>
                    </ul>
                    
                    <h3>The LDA Advantage</h3>
                    <ul>
                        <li>Provides optimal linear separation</li>
                        <li>Mathematically principled approach</li>
                        <li>Works well in moderate dimensions</li>
                        <li>Interpretable projections</li>
                    </ul>
                </div>
                
                <div>
                    <h3>High-Dimensional Reality</h3>
                    <ul>
                        <li>Standard distance measures fail</li>
                        <li>Dimensionality reduction becomes essential</li>
                        <li>Local measures may work better than global</li>
                        <li>Feature selection often more important than algorithms</li>
                    </ul>
                    
                    <h3>Moving Forward</h3>
                    <ul>
                        <li>Start with simple measures for intuition</li>
                        <li>Progress to sophisticated methods as needed</li>
                        <li>Always validate with domain expertise</li>
                        <li>Consider computational trade-offs</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="counter">
        <span id="current">1</span> / <span id="total">10</span>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = 10;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            if (n > totalSlides) currentSlide = 1;
            if (n < 1) currentSlide = totalSlides;
            
            slides.forEach(slide => slide.classList.remove('active'));
            document.getElementById(`slide${currentSlide}`).classList.add('active');
            document.getElementById('current').textContent = currentSlide;
        }

        function nextSlide() {
            currentSlide++;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide--;
            showSlide(currentSlide);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                prevSlide();
            }
        });

        // Initialize
        showSlide(currentSlide);

        // D3.js Visualizations
        function initSeparationConceptViz() {
            const container = d3.select('#separation-concept-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 250;
                const margin = {top: 20, right: 20, bottom: 20, left: 20};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Good separation example
                const goodG = g.append('g')
                    .attr('transform', 'translate(0, 0)');
                
                goodG.append('text')
                    .attr('x', innerWidth/4)
                    .attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .text('Good Separation');
                
                // Generate well-separated clusters
                const cluster1 = Array.from({length: 20}, () => ({
                    x: innerWidth/8 + Math.random() * 30,
                    y: innerHeight/2 + Math.random() * 40 - 20
                }));
                
                const cluster2 = Array.from({length: 20}, () => ({
                    x: innerWidth/8 + 80 + Math.random() * 30,
                    y: innerHeight/2 + Math.random() * 40 - 20
                }));
                
                goodG.selectAll('.cluster1')
                    .data(cluster1)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y + 30)
                    .attr('r', 3)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.7);
                
                goodG.selectAll('.cluster2')
                    .data(cluster2)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y + 30)
                    .attr('r', 3)
                    .attr('fill', '#e67e22')
                    .attr('opacity', 0.7);
                
                // Poor separation example
                const poorG = g.append('g')
                    .attr('transform', `translate(${innerWidth/2}, 0)`);
                
                poorG.append('text')
                    .attr('x', innerWidth/4)
                    .attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .text('Poor Separation');
                
                // Generate overlapping clusters
                const cluster3 = Array.from({length: 20}, () => ({
                    x: innerWidth/8 + Math.random() * 60,
                    y: innerHeight/2 + Math.random() * 60 - 30
                }));
                
                const cluster4 = Array.from({length: 20}, () => ({
                    x: innerWidth/8 + 30 + Math.random() * 60,
                    y: innerHeight/2 + Math.random() * 60 - 30
                }));
                
                poorG.selectAll('.cluster3')
                    .data(cluster3)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y + 30)
                    .attr('r', 3)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.7);
                
                poorG.selectAll('.cluster4')
                    .data(cluster4)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y + 30)
                    .attr('r', 3)
                    .attr('fill', '#e67e22')
                    .attr('opacity', 0.7);
            }
        }

        function initCenterDistanceViz() {
            const container = d3.select('#center-distance-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                const margin = {top: 20, right: 20, bottom: 40, left: 40};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([0, 10])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 8])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale));
                
                g.append('g')
                    .call(d3.axisLeft(yScale));
                
                // Draw class centers
                const center1 = {x: 3, y: 5};
                const center2 = {x: 7, y: 3};
                
                g.append('circle')
                    .attr('cx', xScale(center1.x))
                    .attr('cy', yScale(center1.y))
                    .attr('r', 8)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.8);
                
                g.append('circle')
                    .attr('cx', xScale(center2.x))
                    .attr('cy', yScale(center2.y))
                    .attr('r', 8)
                    .attr('fill', '#e67e22')
                    .attr('opacity', 0.8);
                
                // Draw distance line
                g.append('line')
                    .attr('x1', xScale(center1.x))
                    .attr('y1', yScale(center1.y))
                    .attr('x2', xScale(center2.x))
                    .attr('y2', yScale(center2.y))
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Add distance label
                const midX = (center1.x + center2.x) / 2;
                const midY = (center1.y + center2.y) / 2;
                const distance = Math.sqrt(Math.pow(center2.x - center1.x, 2) + Math.pow(center2.y - center1.y, 2));
                
                g.append('text')
                    .attr('x', xScale(midX))
                    .attr('y', yScale(midY) - 10)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text(`d = ${distance.toFixed(1)}`);
                
                // Add labels
                g.append('text')
                    .attr('x', xScale(center1.x))
                    .attr('y', yScale(center1.y) + 25)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('μ₁');
                
                g.append('text')
                    .attr('x', xScale(center2.x))
                    .attr('y', yScale(center2.y) + 25)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('μ₂');
            }
        }

        function initOutlierImpactViz() {
            const container = d3.select('#outlier-impact-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Without outliers
                const leftG = svg.append('g')
                    .attr('transform', 'translate(20, 20)');
                
                leftG.append('text')
                    .attr('x', 0).attr('y', 0)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('Without Outliers');
                
                const normalData = Array.from({length: 15}, () => ({
                    x: 50 + Math.random() * 40,
                    y: 60 + Math.random() * 40
                }));
                
                leftG.selectAll('.normal-point')
                    .data(normalData)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y + 20)
                    .attr('r', 3)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.7);
                
                // Center
                const normalCenter = {
                    x: normalData.reduce((sum, d) => sum + d.x, 0) / normalData.length,
                    y: normalData.reduce((sum, d) => sum + d.y, 0) / normalData.length + 20
                };
                
                leftG.append('circle')
                    .attr('cx', normalCenter.x)
                    .attr('cy', normalCenter.y)
                    .attr('r', 6)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2);
                
                // With outliers
                const rightG = svg.append('g')
                    .attr('transform', `translate(${width/2 + 20}, 20)`);
                
                rightG.append('text')
                    .attr('x', 0).attr('y', 0)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('With Outliers');
                
                const outlierData = [...normalData, 
                    {x: 20, y: 20}, {x: 120, y: 120}, {x: 130, y: 30}];
                
                outlierData.forEach((d, i) => {
                    const isOutlier = i >= normalData.length;
                    rightG.append('circle')
                        .attr('cx', d.x)
                        .attr('cy', d.y + 20)
                        .attr('r', isOutlier ? 4 : 3)
                        .attr('fill', isOutlier ? '#9b59b6' : '#3498db')
                        .attr('opacity', 0.7);
                });
                
                // Shifted center
                const outlierCenter = {
                    x: outlierData.reduce((sum, d) => sum + d.x, 0) / outlierData.length,
                    y: outlierData.reduce((sum, d) => sum + d.y, 0) / outlierData.length + 20
                };
                
                rightG.append('circle')
                    .attr('cx', outlierCenter.x)
                    .attr('cy', outlierCenter.y)
                    .attr('r', 6)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2);
            }
        }

        function initLDAComparisonViz() {
            const container = d3.select('#lda-comparison-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // PCA vs LDA comparison
                const leftG = svg.append('g')
                    .attr('transform', 'translate(40, 30)');
                
                leftG.append('text')
                    .attr('x', 0).attr('y', 0)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('PCA Direction');
                
                // Generate two classes
                const class1 = Array.from({length: 10}, () => ({
                    x: 30 + Math.random() * 20,
                    y: 40 + Math.random() * 40
                }));
                
                const class2 = Array.from({length: 10}, () => ({
                    x: 70 + Math.random() * 20,
                    y: 80 + Math.random() * 40
                }));
                
                // Draw points
                class1.forEach(d => {
                    leftG.append('circle')
                        .attr('cx', d.x).attr('cy', d.y + 20)
                        .attr('r', 3).attr('fill', '#3498db').attr('opacity', 0.7);
                });
                
                class2.forEach(d => {
                    leftG.append('circle')
                        .attr('cx', d.x).attr('cy', d.y + 20)
                        .attr('r', 3).attr('fill', '#e67e22').attr('opacity', 0.7);
                });
                
                // PCA direction (maximum variance)
                leftG.append('line')
                    .attr('x1', 10).attr('y1', 100)
                    .attr('x2', 110).attr('y2', 40)
                    .attr('stroke', '#95a5a6')
                    .attr('stroke-width', 2);
                
                // LDA example
                const rightG = svg.append('g')
                    .attr('transform', `translate(${width/2 + 40}, 30)`);
                
                rightG.append('text')
                    .attr('x', 0).attr('y', 0)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('LDA Direction');
                
                // Draw same points
                class1.forEach(d => {
                    rightG.append('circle')
                        .attr('cx', d.x).attr('cy', d.y + 20)
                        .attr('r', 3).attr('fill', '#3498db').attr('opacity', 0.7);
                });
                
                class2.forEach(d => {
                    rightG.append('circle')
                        .attr('cx', d.x).attr('cy', d.y + 20)
                        .attr('r', 3).attr('fill', '#e67e22').attr('opacity', 0.7);
                });
                
                // LDA direction (maximum separation)
                rightG.append('line')
                    .attr('x1', 90).attr('y1', 30)
                    .attr('x2', 30).attr('y2', 130)
                    .attr('stroke', '#27ae60')
                    .attr('stroke-width', 2);
            }
        }

        function initStatisticalMeasuresViz() {
            const container = d3.select('#statistical-measures-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                const margin = {top: 20, right: 40, bottom: 40, left: 60};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Sample data for different metrics
                const metrics = ['Fisher Ratio', 'Silhouette', 'Davies-Bouldin', 'Calinski-H'];
                const values = [2.5, 0.7, 0.3, 15.2];
                const normalized = [0.8, 0.7, 0.9, 0.6]; // Normalized for comparison
                
                const xScale = d3.scaleBand()
                    .domain(metrics)
                    .range([0, innerWidth])
                    .padding(0.2);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .selectAll('text')
                    .style('font-size', '10px');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Normalized Score');
                
                // Add bars
                g.selectAll('.bar')
                    .data(normalized)
                    .enter().append('rect')
                    .attr('class', 'bar')
                    .attr('x', (d, i) => xScale(metrics[i]))
                    .attr('y', d => yScale(d))
                    .attr('width', xScale.bandwidth())
                    .attr('height', d => innerHeight - yScale(d))
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.7);
                
                // Add value labels
                g.selectAll('.label')
                    .data(values)
                    .enter().append('text')
                    .attr('class', 'label')
                    .attr('x', (d, i) => xScale(metrics[i]) + xScale.bandwidth()/2)
                    .attr('y', (d, i) => yScale(normalized[i]) - 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text(d => d);
            }
        }

        function initHighDimensionalViz() {
            const container = d3.select('#high-dimensional-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                const margin = {top: 20, right: 40, bottom: 40, left: 60};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Show distance concentration effect
                const dimensions = [2, 5, 10, 20, 50, 100];
                const meanDist = dimensions.map(d => 1.0); // Normalized
                const minDist = dimensions.map(d => Math.max(0.1, 1.0 - d * 0.015));
                const maxDist = dimensions.map(d => Math.min(2.0, 1.0 + d * 0.01));
                
                const xScale = d3.scaleLog()
                    .domain([2, 100])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 2])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.format('d')))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 35)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Dimensions');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Distance Ratio');
                
                // Draw distance range
                const area = d3.area()
                    .x((d, i) => xScale(dimensions[i]))
                    .y0((d, i) => yScale(minDist[i]))
                    .y1((d, i) => yScale(maxDist[i]))
                    .curve(d3.curveMonotoneX);
                
                g.append('path')
                    .datum(dimensions)
                    .attr('fill', '#3498db')
                    .attr('opacity', 0.3)
                    .attr('d', area);
                
                // Mean distance line
                const line = d3.line()
                    .x((d, i) => xScale(dimensions[i]))
                    .y(d => yScale(d))
                    .curve(d3.curveMonotoneX);
                
                g.append('path')
                    .datum(meanDist)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('d', line);
                
                // Add annotation
                g.append('text')
                    .attr('x', innerWidth - 50)
                    .attr('y', 30)
                    .style('font-size', '11px')
                    .text('Distance concentration');
            }
        }

        function initAdvancedMetricsViz() {
            const container = d3.select('#advanced-metrics-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 150;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Show different separation scenarios
                const scenarios = [
                    {name: 'Linear', x: 50, complexity: 'Low', accuracy: 'High'},
                    {name: 'Polynomial', x: 200, complexity: 'Medium', accuracy: 'High'},
                    {name: 'RBF Kernel', x: 350, complexity: 'High', accuracy: 'Very High'},
                    {name: 'Manifold', x: 500, complexity: 'Very High', accuracy: 'Variable'}
                ];
                
                scenarios.forEach(scenario => {
                    const g = svg.append('g')
                        .attr('transform', `translate(${scenario.x - 40}, 20)`);
                    
                    g.append('text')
                        .attr('x', 40).attr('y', 0)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '12px')
                        .style('font-weight', 'bold')
                        .text(scenario.name);
                    
                    g.append('text')
                        .attr('x', 40).attr('y', 110)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .text(`Complexity: ${scenario.complexity}`);
                    
                    g.append('text')
                        .attr('x', 40).attr('y', 125)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .text(`Accuracy: ${scenario.accuracy}`);
                    
                    // Simple visualization for each method
                    if (scenario.name === 'Linear') {
                        g.append('line')
                            .attr('x1', 10).attr('y1', 70)
                            .attr('x2', 70).attr('y2', 30)
                            .attr('stroke', '#3498db')
                            .attr('stroke-width', 2);
                    } else if (scenario.name === 'Polynomial') {
                        const points = Array.from({length: 20}, (_, i) => {
                            const x = i * 4;
                            const y = 50 + 20 * Math.sin(i * 0.5);
                            return {x, y};
                        });
                        
                        const line = d3.line()
                            .x(d => d.x + 10)
                            .y(d => d.y)
                            .curve(d3.curveCardinal);
                        
                        g.append('path')
                            .datum(points)
                            .attr('fill', 'none')
                            .attr('stroke', '#e67e22')
                            .attr('stroke-width', 2)
                            .attr('d', line);
                    }
                    
                    // Add some sample points
                    Array.from({length: 8}, () => {
                        g.append('circle')
                            .attr('cx', 20 + Math.random() * 40)
                            .attr('cy', 30 + Math.random() * 40)
                            .attr('r', 2)
                            .attr('fill', Math.random() > 0.5 ? '#3498db' : '#e67e22')
                            .attr('opacity', 0.6);
                    });
                });
            }
        }

        // Initialize visualizations when slides are shown
        const originalShowSlide = showSlide;
        showSlide = function(n) {
            originalShowSlide(n);
            
            // Initialize visualizations based on current slide
            setTimeout(() => {
                if (currentSlide === 2) initSeparationConceptViz();
                if (currentSlide === 3) initCenterDistanceViz();
                if (currentSlide === 4) initOutlierImpactViz();
                if (currentSlide === 5) initLDAComparisonViz();
                if (currentSlide === 6) initStatisticalMeasuresViz();
                if (currentSlide === 7) initHighDimensionalViz();
                if (currentSlide === 8) initAdvancedMetricsViz();
            }, 100);
        };

        // Initialize current slide visualizations
        setTimeout(() => {
            if (currentSlide === 2) initSeparationConceptViz();
            if (currentSlide === 3) initCenterDistanceViz();
            if (currentSlide === 4) initOutlierImpactViz();
            if (currentSlide === 5) initLDAComparisonViz();
            if (currentSlide === 6) initStatisticalMeasuresViz();
            if (currentSlide === 7) initHighDimensionalViz();
            if (currentSlide === 8) initAdvancedMetricsViz();
        }, 100);
    </script>
</body>
</html>
