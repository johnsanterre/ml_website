<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feedforward Neural Networks</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .slide {
            display: none;
            padding: 30px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .slide.active {
            display: block;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
        }
        h2 {
            color: #3498db;
            margin-top: 0;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .progress {
            margin-top: 10px;
            text-align: center;
        }
        .example {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 10px 15px;
            margin: 15px 0;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .visualization {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px 0;
            background-color: #f8f9fa;
        }
        .neuron-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .neuron {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .arrow {
            font-size: 24px;
            color: #2c3e50;
        }
    </style>
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- D3.js for visualizations -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- Slide 1: Title -->
    <div class="slide active" id="slide1">
        <h1>Feedforward Neural Networks</h1>
        <h2>The Foundation of Deep Learning</h2>
        <p>Understanding the basic building blocks of artificial neural networks</p>
        <div class="example">
            <strong>Key Concept:</strong> Neural networks are computational models inspired by biological neural networks that can learn complex patterns from data through layers of interconnected nodes.
        </div>
        <div class="example">
            <strong>Notation Used Throughout:</strong>
            <ul>
                <li>$y$ = true target values (ground truth)</li>
                <li>$\hat{y}$ = predicted values (network output)</li>
                <li>$\mathcal{L}$ = loss function (what we minimize)</li>
                <li>Goal: Minimize $\mathcal{L}(y, \hat{y})$ to make predictions closer to truth</li>
            </ul>
        </div>
        <ul>
            <li>Mathematical functions that approximate complex relationships</li>
            <li>Universal function approximators</li>
            <li>Foundation for modern deep learning architectures</li>
        </ul>
    </div>

    <!-- Slide 2: Historical Context -->
    <div class="slide" id="slide2">
        <h1>Historical Context</h1>
        <h2>From Perceptrons to Deep Networks</h2>
        <ul>
            <li><strong>1943:</strong> McCulloch-Pitts neuron model</li>
            <li><strong>1957:</strong> Rosenblatt's Perceptron</li>
            <li><strong>1969:</strong> Minsky & Papert show perceptron limitations</li>
            <li><strong>1986:</strong> Backpropagation algorithm popularized</li>
            <li><strong>2006:</strong> Deep learning renaissance begins</li>
            <li><strong>2012:</strong> AlexNet wins ImageNet competition</li>
        </ul>
        <div class="example">
            <strong>Key Insight:</strong> Neural networks experienced periods of decline ("AI winters") and resurgence, ultimately leading to today's deep learning revolution.
        </div>
    </div>

    <!-- Slide 3: Basic Neuron Structure -->
    <div class="slide" id="slide3">
        <h1>The Artificial Neuron</h1>
        <h2>Basic Computational Unit</h2>
        <div class="neuron-diagram">
            <div>x₁</div>
            <div class="arrow">→</div>
            <div class="neuron">Σ</div>
            <div class="arrow">→</div>
            <div>f(·)</div>
            <div class="arrow">→</div>
            <div>ŷ</div>
        </div>
        <div class="example">
            <strong>Mathematical Formula:</strong>
            $$\hat{y} = f\left(\sum_{i=1}^{n} w_i x_i + b\right)$$
            <p>Where $w_i$ are weights, $x_i$ are inputs, $b$ is bias, $f$ is the activation function, and $\hat{y}$ is the predicted output</p>
        </div>
        <div id="neuron-viz" class="visualization"></div>
    </div>

    <!-- Slide 4: Network Architecture -->
    <div class="slide" id="slide4">
        <h1>Network Architecture</h1>
        <h2>Layers and Connections</h2>
        <ul>
            <li><strong>Input Layer:</strong> Receives raw data features</li>
            <li><strong>Hidden Layer(s):</strong> Process and transform information</li>
            <li><strong>Output Layer:</strong> Produces final predictions</li>
            <li><strong>Feedforward:</strong> Information flows in one direction</li>
        </ul>
        <div class="example">
            <strong>Layer Dimensions:</strong>
            <ul>
                <li>Input layer: n neurons (n = number of features)</li>
                <li>Hidden layers: arbitrary number of neurons</li>
                <li>Output layer: k neurons (k = number of classes/outputs)</li>
            </ul>
        </div>
        <div id="network-architecture-viz" class="visualization"></div>
    </div>

    <!-- Slide 5: Activation Functions -->
    <div class="slide" id="slide5">
        <h1>Activation Functions</h1>
        <h2>Introducing Non-linearity</h2>
        <div class="example">
            <strong>Common Activation Functions:</strong>
            <ul>
                <li><strong>Sigmoid:</strong> $\sigma(x) = \frac{1}{1 + e^{-x}}$</li>
                <li><strong>Tanh:</strong> $\tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}$</li>
                <li><strong>ReLU:</strong> $\text{ReLU}(x) = \max(0, x)$</li>
                <li><strong>Softmax:</strong> $\text{softmax}(x_i) = \frac{e^{x_i}}{\sum_{j=1}^{k} e^{x_j}}$</li>
            </ul>
        </div>
        <p><strong>Purpose:</strong> Enable networks to learn non-linear patterns and relationships</p>
        <div id="activation-functions-viz" class="visualization"></div>
    </div>

    <!-- Slide 6: Forward Propagation -->
    <div class="slide" id="slide6">
        <h1>Forward Propagation</h1>
        <h2>Computing Network Output</h2>
        <div class="example">
            <strong>Step-by-step Process:</strong>
            <ol>
                <li>Initialize input values: $\mathbf{x} = [x_1, x_2, ..., x_n]$ (where $\mathbf{a}^{(0)} = \mathbf{x}$)</li>
                <li>For each layer $l$: $\mathbf{z}^{(l)} = \mathbf{W}^{(l)} \mathbf{a}^{(l-1)} + \mathbf{b}^{(l)}$</li>
                <li>Apply activation: $\mathbf{a}^{(l)} = f(\mathbf{z}^{(l)})$</li>
                <li>Repeat until output layer: $\hat{\mathbf{y}} = \mathbf{a}^{(L)}$ (final prediction)</li>
            </ol>
        </div>
        <p><strong>Matrix Representation:</strong> Enables efficient computation using vectorized operations</p>
        <div id="forward-propagation-viz" class="visualization"></div>
    </div>

    <!-- Slide 7: Loss Functions -->
    <div class="slide" id="slide7">
        <h1>Loss Functions</h1>
        <h2>Measuring Network Performance</h2>
        <div class="example">
            <strong>Common Loss Functions:</strong>
            <ul>
                <li><strong>Mean Squared Error (Regression):</strong> $\mathcal{L}_{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2$</li>
                <li><strong>Cross-Entropy (Classification):</strong> $\mathcal{L}_{CE} = -\sum_{i=1}^{k} y_i \log(\hat{y}_i)$</li>
                <li><strong>Binary Cross-Entropy:</strong> $\mathcal{L}_{BCE} = -[y \log(\hat{y}) + (1-y) \log(1-\hat{y})]$</li>
            </ul>
            <p>Where $y$ is the true target value and $\hat{y}$ is the predicted value</p>
        </div>
        <p><strong>Purpose:</strong> Quantify the difference between predicted ($\hat{y}$) and actual outputs ($y$)</p>
        <p><strong>Goal:</strong> Minimize the loss function $\mathcal{L}$ to improve model predictions</p>
        <div id="loss-functions-viz" class="visualization"></div>
    </div>

    <!-- Slide 8: Backpropagation -->
    <div class="slide" id="slide8">
        <h1>Backpropagation Algorithm</h1>
        <h2>Learning Through Gradient Descent</h2>
        <div class="example">
            <strong>Key Steps:</strong>
            <ol>
                <li><strong>Forward pass:</strong> Compute predictions $\hat{y}$ and loss $\mathcal{L}(y, \hat{y})$</li>
                <li><strong>Backward pass:</strong> Compute gradients $\frac{\partial \mathcal{L}}{\partial w}$ using chain rule</li>
                <li><strong>Update weights:</strong> $w_{new} = w_{old} - \alpha \frac{\partial \mathcal{L}}{\partial w}$</li>
                <li><strong>Repeat:</strong> Until convergence or stopping criteria</li>
            </ol>
        </div>
        <div class="example">
            <strong>Chain Rule Application:</strong>
            $$\frac{\partial \mathcal{L}}{\partial w_{ij}^{(l)}} = \frac{\partial \mathcal{L}}{\partial a_j^{(l)}} \cdot \frac{\partial a_j^{(l)}}{\partial z_j^{(l)}} \cdot \frac{\partial z_j^{(l)}}{\partial w_{ij}^{(l)}}$$
            <p>Where $\mathcal{L}$ is the loss function we want to <strong>minimize</strong></p>
        </div>
        <div id="backpropagation-viz" class="visualization"></div>
    </div>

    <!-- Slide 9: Training Process -->
    <div class="slide" id="slide9">
        <h1>Training Process</h1>
        <h2>Optimizing Network Parameters</h2>
        <div class="example">
            <strong>Training Algorithm:</strong>
            <code>
                for epoch in range(num_epochs):<br>
                &nbsp;&nbsp;&nbsp;&nbsp;for batch in data_loader:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Forward pass: compute predictions<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_hat = network(batch.inputs)  # predicted values<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loss = loss_function(y_hat, batch.y)  # minimize this<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Backward pass: compute gradients<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gradients = compute_gradients(loss)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Update parameters to minimize loss<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optimizer.step(gradients)
            </code>
        </div>
        <p><strong>Objective:</strong> Minimize loss $\mathcal{L}(y, \hat{y})$ by adjusting weights and biases</p>
        <p><strong>Key Hyperparameters:</strong> Learning rate, batch size, number of epochs</p>
        <div id="training-process-viz" class="visualization"></div>
    </div>

    <!-- Slide 10: Common Challenges -->
    <div class="slide" id="slide10">
        <h1>Training Challenges</h1>
        <h2>Common Issues and Solutions</h2>
        <ul>
            <li><strong>Vanishing Gradients:</strong> Gradients become too small in deep networks
                <ul><li>Solutions: Better activation functions (ReLU), normalization</li></ul>
            </li>
            <li><strong>Exploding Gradients:</strong> Gradients become too large
                <ul><li>Solutions: Gradient clipping, proper initialization</li></ul>
            </li>
            <li><strong>Overfitting:</strong> Model memorizes training data
                <ul><li>Solutions: Regularization, dropout, early stopping</li></ul>
            </li>
            <li><strong>Local Minima:</strong> Optimization gets stuck
                <ul><li>Solutions: Better optimizers (Adam, RMSprop), momentum</li></ul>
            </li>
        </ul>
        <div id="challenges-viz" class="visualization"></div>
    </div>

    <!-- Slide 11: Regularization Techniques -->
    <div class="slide" id="slide11">
        <h1>Regularization Techniques</h1>
        <h2>Preventing Overfitting</h2>
        <div class="example">
            <strong>Common Techniques:</strong>
            <ul>
                <li><strong>L1 Regularization:</strong> $\mathcal{L}_{total} = \mathcal{L}_{original} + \lambda \sum |w_i|$</li>
                <li><strong>L2 Regularization:</strong> $\mathcal{L}_{total} = \mathcal{L}_{original} + \lambda \sum w_i^2$</li>
                <li><strong>Dropout:</strong> Randomly set neurons to zero during training</li>
                <li><strong>Early Stopping:</strong> Stop training when validation loss increases</li>
            </ul>
            <p>We minimize the total loss $\mathcal{L}_{total}$ which includes penalty terms</p>
        </div>
        <p><strong>Goal:</strong> Balance model complexity with generalization ability</p>
        <div id="regularization-viz" class="visualization"></div>
    </div>

    <!-- Slide 12: Modern Optimizers -->
    <div class="slide" id="slide12">
        <h1>Modern Optimization</h1>
        <h2>Beyond Basic Gradient Descent</h2>
        <div class="example">
            <strong>Advanced Optimizers:</strong>
            <ul>
                <li><strong>Momentum:</strong> $v_t = \gamma v_{t-1} + \alpha \nabla \mathcal{L}$</li>
                <li><strong>Adam:</strong> Combines momentum with adaptive learning rates</li>
                <li><strong>RMSprop:</strong> Adapts learning rate per parameter</li>
                <li><strong>AdaGrad:</strong> Accumulates squared gradients</li>
            </ul>
            <p>All optimize by minimizing the loss function $\mathcal{L}$ more effectively than basic gradient descent</p>
        </div>
        <p><strong>Benefits:</strong> Faster convergence, better handling of sparse gradients, adaptive learning rates</p>
        <div id="optimizers-viz" class="visualization"></div>
    </div>

    <!-- Slide 13: Key Takeaways -->
    <div class="slide" id="slide13">
        <h1>Key Takeaways</h1>
        <h2>Feedforward Neural Networks</h2>
        <ul>
            <li>Neural networks are powerful universal function approximators</li>
            <li>Architecture matters: depth, width, and activation functions</li>
            <li>Training requires careful consideration of:
                <ul>
                    <li>Loss functions and optimization algorithms</li>
                    <li>Regularization and overfitting prevention</li>
                    <li>Hyperparameter tuning</li>
                </ul>
            </li>
            <li>Backpropagation enables efficient gradient computation</li>
            <li>Modern techniques address traditional challenges</li>
            <li>Foundation for advanced architectures (CNNs, RNNs, Transformers)</li>
        </ul>
        <div class="example">
            <strong>Next Steps:</strong> Explore specialized architectures for specific domains (computer vision, NLP, etc.)
        </div>
    </div>

    <!-- Navigation Controls -->
    <div class="controls">
        <button onclick="prevSlide()">Previous</button>
        <div class="progress">Slide <span id="current">1</span> of <span id="total">13</span></div>
        <button onclick="nextSlide()">Next</button>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = 13;

        function showSlide(n) {
            // Hide all slides
            const slides = document.querySelectorAll('.slide');
            slides.forEach(slide => {
                slide.classList.remove('active');
            });
            
            // Show the current slide
            document.getElementById('slide' + n).classList.add('active');
            document.getElementById('current').textContent = n;
            
            // Initialize visualizations for the current slide if needed
            setTimeout(() => {
                initializeVisualizationForSlide(n);
            }, 100);
        }

        function nextSlide() {
            if (currentSlide < totalSlides) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 1) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowRight') {
                nextSlide();
            } else if (event.key === 'ArrowLeft') {
                prevSlide();
            }
        });
        
        // Initialize all visualizations when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initializeAllVisualizations();
            }, 1000);
            
            setTimeout(() => {
                initializeVisualizationForSlide(currentSlide);
            }, 1500);
        });
        
        function initializeAllVisualizations() {
            try {
                initNeuronViz();
                initNetworkArchitectureViz();
                initActivationFunctionsViz();
                initForwardPropagationViz();
                initLossFunctionsViz();
                initBackpropagationViz();
                initTrainingProcessViz();
                initChallengesViz();
                initRegularizationViz();
                initOptimizersViz();
            } catch (error) {
                console.error('Error initializing visualizations:', error);
            }
        }
        
        // Neuron Visualization
        function initNeuronViz() {
            const container = d3.select('#neuron-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 40, left: 40};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Draw neuron components
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Inputs
                const inputs = [
                    {x: 80, y: centerY - 60, label: 'x₁', weight: 'w₁'},
                    {x: 80, y: centerY - 20, label: 'x₂', weight: 'w₂'},
                    {x: 80, y: centerY + 20, label: 'x₃', weight: 'w₃'},
                    {x: 80, y: centerY + 60, label: 'bias', weight: 'b'}
                ];
                
                // Draw input nodes
                inputs.forEach(input => {
                    svg.append('circle')
                        .attr('cx', input.x)
                        .attr('cy', input.y)
                        .attr('r', 15)
                        .attr('fill', '#3498db')
                        .attr('stroke', '#2c3e50')
                        .attr('stroke-width', 2);
                    
                    svg.append('text')
                        .attr('x', input.x)
                        .attr('y', input.y + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(input.label);
                    
                    // Connection lines
                    svg.append('line')
                        .attr('x1', input.x + 15)
                        .attr('y1', input.y)
                        .attr('x2', centerX - 40)
                        .attr('y2', centerY)
                        .attr('stroke', '#2c3e50')
                        .attr('stroke-width', 2);
                    
                    // Weight labels
                    const midX = (input.x + 15 + centerX - 40) / 2;
                    const midY = (input.y + centerY) / 2;
                    svg.append('text')
                        .attr('x', midX)
                        .attr('y', midY - 5)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '10px')
                        .attr('fill', '#e74c3c')
                        .attr('font-weight', 'bold')
                        .text(input.weight);
                });
                
                // Neuron body
                svg.append('circle')
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .attr('r', 35)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 3);
                
                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '20px')
                    .attr('font-weight', 'bold')
                    .text('Σ');
                
                // Activation function
                svg.append('rect')
                    .attr('x', centerX + 60)
                    .attr('y', centerY - 20)
                    .attr('width', 40)
                    .attr('height', 40)
                    .attr('fill', '#2ecc71')
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', centerX + 80)
                    .attr('y', centerY + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('f(·)');
                
                // Connection to activation
                svg.append('line')
                    .attr('x1', centerX + 35)
                    .attr('y1', centerY)
                    .attr('x2', centerX + 60)
                    .attr('y2', centerY)
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2);
                
                // Output
                svg.append('circle')
                    .attr('cx', centerX + 140)
                    .attr('cy', centerY)
                    .attr('r', 15)
                    .attr('fill', '#f39c12')
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', centerX + 140)
                    .attr('y', centerY + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('ŷ');
                
                // Connection to output
                svg.append('line')
                    .attr('x1', centerX + 100)
                    .attr('y1', centerY)
                    .attr('x2', centerX + 125)
                    .attr('y2', centerY)
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2);
            }
        }
        
        // Network Architecture Visualization
        function initNetworkArchitectureViz() {
            const container = d3.select('#network-architecture-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Define layer structure
                const layers = [
                    {name: 'Input', neurons: 3, x: 100},
                    {name: 'Hidden 1', neurons: 4, x: 250},
                    {name: 'Hidden 2', neurons: 4, x: 400},
                    {name: 'Output', neurons: 2, x: 550}
                ];
                
                const colors = ['#3498db', '#e74c3c', '#e74c3c', '#f39c12'];
                
                // Draw connections first (so they appear behind neurons)
                for (let i = 0; i < layers.length - 1; i++) {
                    const currentLayer = layers[i];
                    const nextLayer = layers[i + 1];
                    
                    for (let j = 0; j < currentLayer.neurons; j++) {
                        for (let k = 0; k < nextLayer.neurons; k++) {
                            const y1 = (height / 2) - ((currentLayer.neurons - 1) * 25) / 2 + j * 25;
                            const y2 = (height / 2) - ((nextLayer.neurons - 1) * 25) / 2 + k * 25;
                            
                            svg.append('line')
                                .attr('x1', currentLayer.x + 15)
                                .attr('y1', y1)
                                .attr('x2', nextLayer.x - 15)
                                .attr('y2', y2)
                                .attr('stroke', '#bdc3c7')
                                .attr('stroke-width', 1)
                                .attr('opacity', 0.6);
                        }
                    }
                }
                
                // Draw neurons
                layers.forEach((layer, layerIndex) => {
                    for (let i = 0; i < layer.neurons; i++) {
                        const y = (height / 2) - ((layer.neurons - 1) * 25) / 2 + i * 25;
                        
                        svg.append('circle')
                            .attr('cx', layer.x)
                            .attr('cy', y)
                            .attr('r', 12)
                            .attr('fill', colors[layerIndex])
                            .attr('stroke', '#2c3e50')
                            .attr('stroke-width', 2);
                    }
                    
                    // Layer labels
                    svg.append('text')
                        .attr('x', layer.x)
                        .attr('y', height - 20)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '14px')
                        .attr('font-weight', 'bold')
                        .text(layer.name);
                });
            }
        }
        
        // Activation Functions Visualization
        function initActivationFunctionsViz() {
            const container = d3.select('#activation-functions-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 40, left: 40};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([-5, 5])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([-1.5, 1.5])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale));
                
                g.append('g')
                    .call(d3.axisLeft(yScale));
                
                // Generate data points
                const data = d3.range(-5, 5.1, 0.1);
                
                // Sigmoid function
                const sigmoidData = data.map(x => ({x, y: 1 / (1 + Math.exp(-x))}));
                const sigmoidLine = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveBasis);
                
                // Tanh function
                const tanhData = data.map(x => ({x, y: Math.tanh(x)}));
                const tanhLine = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveBasis);
                
                // ReLU function
                const reluData = data.map(x => ({x, y: Math.max(0, x)}));
                const reluLine = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y));
                
                // Draw functions
                g.append('path')
                    .datum(sigmoidData)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 3)
                    .attr('d', sigmoidLine);
                
                g.append('path')
                    .datum(tanhData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', tanhLine);
                
                g.append('path')
                    .datum(reluData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2ecc71')
                    .attr('stroke-width', 3)
                    .attr('d', reluLine);
                
                // Add labels
                g.append('text')
                    .attr('x', xScale(3))
                    .attr('y', yScale(0.8))
                    .attr('fill', '#3498db')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Sigmoid');
                
                g.append('text')
                    .attr('x', xScale(2))
                    .attr('y', yScale(0.9))
                    .attr('fill', '#e74c3c')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Tanh');
                
                g.append('text')
                    .attr('x', xScale(2))
                    .attr('y', yScale(1.2))
                    .attr('fill', '#2ecc71')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('ReLU');
            }
        }
        
        // Forward Propagation Visualization
        function initForwardPropagationViz() {
            const container = d3.select('#forward-propagation-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 40, left: 40};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Network structure for demonstration
                const layers = [
                    {name: 'Input', neurons: [{value: 'x₁', activation: '0.8'}, {value: 'x₂', activation: '0.3'}], x: 80},
                    {name: 'Hidden', neurons: [{value: 'h₁', activation: '0.6'}, {value: 'h₂', activation: '0.9'}, {value: 'h₃', activation: '0.2'}], x: 220},
                    {name: 'Output', neurons: [{value: 'ŷ', activation: '0.7'}], x: 360}
                ];
                
                const colors = ['#3498db', '#e74c3c', '#f39c12'];
                
                // Draw connections with weights
                const weights = [
                    [{from: 0, to: 0, weight: '0.5'}, {from: 0, to: 1, weight: '0.8'}, {from: 0, to: 2, weight: '-0.3'}],
                    [{from: 1, to: 0, weight: '0.7'}, {from: 1, to: 1, weight: '0.2'}, {from: 1, to: 2, weight: '0.9'}],
                    [{from: 0, to: 0, weight: '0.4'}, {from: 1, to: 0, weight: '0.6'}, {from: 2, to: 0, weight: '-0.2'}]
                ];
                
                // Draw connections between layers
                for (let layerIdx = 0; layerIdx < layers.length - 1; layerIdx++) {
                    const currentLayer = layers[layerIdx];
                    const nextLayer = layers[layerIdx + 1];
                    
                    currentLayer.neurons.forEach((neuron, i) => {
                        nextLayer.neurons.forEach((nextNeuron, j) => {
                            const y1 = height/2 - (currentLayer.neurons.length - 1) * 20 + i * 40;
                            const y2 = height/2 - (nextLayer.neurons.length - 1) * 20 + j * 40;
                            
                            const weight = weights[layerIdx] && weights[layerIdx][i] ? weights[layerIdx][i].weight : '0.5';
                            const isNegative = parseFloat(weight) < 0;
                            
                            svg.append('line')
                                .attr('x1', currentLayer.x + 20)
                                .attr('y1', y1)
                                .attr('x2', nextLayer.x - 20)
                                .attr('y2', y2)
                                .attr('stroke', isNegative ? '#e74c3c' : '#2ecc71')
                                .attr('stroke-width', Math.abs(parseFloat(weight)) * 4 + 1)
                                .attr('opacity', 0.7);
                            
                            // Weight labels
                            const midX = (currentLayer.x + nextLayer.x) / 2;
                            const midY = (y1 + y2) / 2;
                            svg.append('text')
                                .attr('x', midX)
                                .attr('y', midY - 3)
                                .attr('text-anchor', 'middle')
                                .attr('font-size', '9px')
                                .attr('fill', '#2c3e50')
                                .attr('font-weight', 'bold')
                                .text(weight);
                        });
                    });
                }
                
                // Draw neurons
                layers.forEach((layer, layerIdx) => {
                    layer.neurons.forEach((neuron, i) => {
                        const y = height/2 - (layer.neurons.length - 1) * 20 + i * 40;
                        
                        // Neuron circle
                        svg.append('circle')
                            .attr('cx', layer.x)
                            .attr('cy', y)
                            .attr('r', 18)
                            .attr('fill', colors[layerIdx])
                            .attr('stroke', '#2c3e50')
                            .attr('stroke-width', 2);
                        
                        // Neuron label
                        svg.append('text')
                            .attr('x', layer.x)
                            .attr('y', y - 2)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '11px')
                            .attr('font-weight', 'bold')
                            .attr('fill', 'white')
                            .text(neuron.value);
                        
                        // Activation value
                        svg.append('text')
                            .attr('x', layer.x)
                            .attr('y', y + 8)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '9px')
                            .attr('fill', 'white')
                            .text(neuron.activation);
                    });
                    
                    // Layer labels
                    svg.append('text')
                        .attr('x', layer.x)
                        .attr('y', height - 10)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(layer.name);
                });
                
                // Add title
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', 20)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Forward Propagation: z = W·a + b, then a = f(z)');
            }
        }
        
        function initLossFunctionsViz() {
            const container = d3.select('#loss-functions-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 40, left: 40};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 4])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 35)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Predicted Probability (ŷ)');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -35)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Loss Value');
                
                // Generate data for cross-entropy loss when y=1
                const data = d3.range(0.01, 1, 0.01);
                const crossEntropyData = data.map(yHat => ({
                    yHat, 
                    loss: -Math.log(yHat) // -log(ŷ) when y=1
                }));
                
                // Generate data for MSE when y=1
                const mseData = data.map(yHat => ({
                    yHat,
                    loss: Math.pow(1 - yHat, 2) // (1 - ŷ)² when y=1
                }));
                
                // Create line generators
                const crossEntropyLine = d3.line()
                    .x(d => xScale(d.yHat))
                    .y(d => yScale(d.loss))
                    .curve(d3.curveBasis);
                
                const mseLine = d3.line()
                    .x(d => xScale(d.yHat))
                    .y(d => yScale(d.loss))
                    .curve(d3.curveBasis);
                
                // Draw lines
                g.append('path')
                    .datum(crossEntropyData.filter(d => d.loss <= 4))
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', crossEntropyLine);
                
                g.append('path')
                    .datum(mseData)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 3)
                    .attr('d', mseLine);
                
                // Add labels and annotations
                g.append('text')
                    .attr('x', xScale(0.2))
                    .attr('y', yScale(2.5))
                    .attr('fill', '#e74c3c')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Cross-Entropy');
                
                g.append('text')
                    .attr('x', xScale(0.2))
                    .attr('y', yScale(0.6))
                    .attr('fill', '#3498db')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('MSE');
                
                // Add vertical line at ŷ = 1 (perfect prediction)
                g.append('line')
                    .attr('x1', xScale(1))
                    .attr('y1', yScale(0))
                    .attr('x2', xScale(1))
                    .attr('y2', yScale(4))
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3');
                
                g.append('text')
                    .attr('x', xScale(0.95))
                    .attr('y', yScale(3.5))
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('fill', '#2c3e50')
                    .text('Perfect\nPrediction');
                
                // Add title
                g.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Loss Functions: When True Label y = 1');
            }
        }
        
        function initBackpropagationViz() {
            const container = d3.select('#backpropagation-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                
                // Create a simple text-based explanation instead of complex visualization
                const div = container.append('div')
                    .style('padding', '20px')
                    .style('background-color', '#f8f9fa')
                    .style('border-radius', '8px')
                    .style('border-left', '4px solid #e74c3c')
                    .style('font-family', 'Arial, sans-serif');
                
                div.append('h3')
                    .style('margin-top', '0')
                    .style('color', '#e74c3c')
                    .style('text-align', 'center')
                    .text('Backpropagation Flow');
                
                // Simple visual representation using text
                div.append('div')
                    .style('text-align', 'center')
                    .style('font-family', 'monospace')
                    .style('font-size', '16px')
                    .style('margin', '20px 0')
                    .style('color', '#2c3e50')
                    .html(`
                        Input → Hidden → Output → <strong style="color: #e74c3c;">ℒ(y, ŷ)</strong><br>
                        <span style="color: #e74c3c;">←←←←← ∂ℒ/∂w ←←←←←</span>
                    `);
                
                div.append('div')
                    .style('margin-top', '15px')
                    .html(`
                        <strong>Step-by-step process:</strong><br>
                        <span style="color: #e74c3c;">1.</span> Compute loss ℒ(y, ŷ) at output layer<br>
                        <span style="color: #e74c3c;">2.</span> Calculate ∂ℒ/∂ŷ (gradient w.r.t. output)<br>
                        <span style="color: #e74c3c;">3.</span> Use chain rule: ∂ℒ/∂w = ∂ℒ/∂ŷ × ∂ŷ/∂z × ∂z/∂w<br>
                        <span style="color: #e74c3c;">4.</span> Propagate gradients backward through each layer<br>
                        <span style="color: #e74c3c;">5.</span> Update weights: w ← w - α(∂ℒ/∂w)
                    `);
                
                div.append('div')
                    .style('margin-top', '15px')
                    .style('font-style', 'italic')
                    .style('color', '#7f8c8d')
                    .text('The algorithm efficiently computes gradients for all parameters in a single backward pass through the network.');
            }
        }
        
        function initTrainingProcessViz() {
            const container = d3.select('#training-process-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 60, left: 60};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([0, 50])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 2])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 40)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Training Epochs');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Loss ℒ(y, ŷ)');
                
                // Generate training and validation loss data
                const trainingData = [];
                const validationData = [];
                
                for (let epoch = 0; epoch <= 50; epoch++) {
                    // Training loss: exponential decay with noise
                    const trainLoss = 1.8 * Math.exp(-epoch * 0.08) + 0.05 + Math.random() * 0.05;
                    trainingData.push({epoch, loss: trainLoss});
                    
                    // Validation loss: similar but with some overfitting at the end
                    const valLoss = 1.7 * Math.exp(-epoch * 0.07) + 0.08 + 
                                   (epoch > 35 ? (epoch - 35) * 0.01 : 0) + Math.random() * 0.08;
                    validationData.push({epoch, loss: valLoss});
                }
                
                // Create line generators
                const line = d3.line()
                    .x(d => xScale(d.epoch))
                    .y(d => yScale(d.loss))
                    .curve(d3.curveBasis);
                
                // Draw training loss
                g.append('path')
                    .datum(trainingData)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                // Draw validation loss
                g.append('path')
                    .datum(validationData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                // Add early stopping line
                g.append('line')
                    .attr('x1', xScale(35))
                    .attr('y1', yScale(0))
                    .attr('x2', xScale(35))
                    .attr('y2', yScale(2))
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Add labels
                g.append('text')
                    .attr('x', xScale(25))
                    .attr('y', yScale(0.3))
                    .attr('fill', '#3498db')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Training Loss');
                
                g.append('text')
                    .attr('x', xScale(25))
                    .attr('y', yScale(0.5))
                    .attr('fill', '#e74c3c')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Validation Loss');
                
                g.append('text')
                    .attr('x', xScale(37))
                    .attr('y', yScale(1.8))
                    .attr('fill', '#f39c12')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .text('Early Stopping');
                
                // Add annotations
                g.append('text')
                    .attr('x', xScale(45))
                    .attr('y', yScale(0.7))
                    .attr('fill', '#7f8c8d')
                    .attr('font-size', '10px')
                    .text('Overfitting');
                
                // Add title
                g.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Training Process: Minimizing Loss ℒ(y, ŷ) Over Time');
            }
        }
        
        function initChallengesViz() {
            const container = d3.select('#challenges-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 60, left: 60};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([1, 10])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLog()
                    .domain([0.001, 10])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 40)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Network Depth (Number of Layers)');
                
                g.append('g')
                    .call(d3.axisLeft(yScale).tickFormat(d3.format('.3f')))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Gradient Magnitude |∂ℒ/∂w|');
                
                // Generate gradient data
                const vanishingData = [];
                const explodingData = [];
                const normalData = [];
                
                for (let depth = 1; depth <= 10; depth++) {
                    // Vanishing gradients: exponential decay
                    vanishingData.push({depth, gradient: Math.pow(0.5, depth)});
                    
                    // Exploding gradients: exponential growth
                    explodingData.push({depth, gradient: Math.pow(1.5, depth) * 0.01});
                    
                    // Well-behaved gradients
                    normalData.push({depth, gradient: 0.1 + Math.random() * 0.05});
                }
                
                // Create line generators
                const line = d3.line()
                    .x(d => xScale(d.depth))
                    .y(d => yScale(d.gradient))
                    .curve(d3.curveBasis);
                
                // Draw gradient lines
                g.append('path')
                    .datum(vanishingData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                g.append('path')
                    .datum(explodingData.filter(d => d.gradient <= 10))
                    .attr('fill', 'none')
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                g.append('path')
                    .datum(normalData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2ecc71')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                // Add horizontal reference line at gradient = 1
                g.append('line')
                    .attr('x1', 0)
                    .attr('y1', yScale(1))
                    .attr('x2', innerWidth)
                    .attr('y2', yScale(1))
                    .attr('stroke', '#95a5a6')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3');
                
                // Add labels
                g.append('text')
                    .attr('x', xScale(8))
                    .attr('y', yScale(0.01))
                    .attr('fill', '#e74c3c')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold')
                    .text('Vanishing Gradients');
                
                g.append('text')
                    .attr('x', xScale(7))
                    .attr('y', yScale(5))
                    .attr('fill', '#f39c12')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold')
                    .text('Exploding Gradients');
                
                g.append('text')
                    .attr('x', xScale(6))
                    .attr('y', yScale(0.08))
                    .attr('fill', '#2ecc71')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold')
                    .text('Well-behaved');
                
                // Add reference line label
                g.append('text')
                    .attr('x', xScale(1.2))
                    .attr('y', yScale(1) - 5)
                    .attr('fill', '#95a5a6')
                    .attr('font-size', '10px')
                    .text('Ideal gradient magnitude');
                
                // Add title
                g.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Gradient Flow Problems in Deep Networks');
            }
        }
        
        function initRegularizationViz() {
            const container = d3.select('#regularization-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 120, bottom: 60, left: 60};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 40)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Training Epochs');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Accuracy');
                
                // Generate data for different scenarios
                const noRegTraining = [];
                const noRegValidation = [];
                const withRegTraining = [];
                const withRegValidation = [];
                
                for (let epoch = 0; epoch <= 100; epoch++) {
                    // No regularization: overfitting
                    const noRegTrain = Math.min(0.95, 0.5 + (epoch * 0.008) + Math.random() * 0.02);
                    const noRegVal = Math.min(0.8, 0.5 + (epoch * 0.004) - (epoch > 40 ? (epoch - 40) * 0.002 : 0) + Math.random() * 0.03);
                    
                    noRegTraining.push({epoch, accuracy: noRegTrain});
                    noRegValidation.push({epoch, accuracy: noRegVal});
                    
                    // With regularization: better generalization
                    const withRegTrain = Math.min(0.85, 0.5 + (epoch * 0.005) + Math.random() * 0.02);
                    const withRegVal = Math.min(0.82, 0.5 + (epoch * 0.0045) + Math.random() * 0.02);
                    
                    withRegTraining.push({epoch, accuracy: withRegTrain});
                    withRegValidation.push({epoch, accuracy: withRegVal});
                }
                
                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.epoch))
                    .y(d => yScale(d.accuracy))
                    .curve(d3.curveBasis);
                
                // Draw lines
                g.append('path')
                    .datum(noRegTraining)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .attr('d', line);
                
                g.append('path')
                    .datum(noRegValidation)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .attr('d', line);
                
                g.append('path')
                    .datum(withRegTraining)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                g.append('path')
                    .datum(withRegValidation)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                // Add legend
                const legend = svg.append('g')
                    .attr('transform', `translate(${width - 110}, 50)`);
                
                // Legend items
                const legendItems = [
                    {text: 'Train (No Reg)', color: '#3498db', dash: '5,5'},
                    {text: 'Val (No Reg)', color: '#e74c3c', dash: '5,5'},
                    {text: 'Train (With Reg)', color: '#3498db', dash: 'none'},
                    {text: 'Val (With Reg)', color: '#e74c3c', dash: 'none'}
                ];
                
                legendItems.forEach((item, i) => {
                    legend.append('line')
                        .attr('x1', 0)
                        .attr('y1', i * 20)
                        .attr('x2', 20)
                        .attr('y2', i * 20)
                        .attr('stroke', item.color)
                        .attr('stroke-width', item.dash === 'none' ? 3 : 2)
                        .attr('stroke-dasharray', item.dash);
                    
                    legend.append('text')
                        .attr('x', 25)
                        .attr('y', i * 20 + 4)
                        .attr('font-size', '10px')
                        .text(item.text);
                });
                
                // Add title
                g.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Regularization Effects on Overfitting');
                
                // Add annotations
                g.append('text')
                    .attr('x', xScale(70))
                    .attr('y', yScale(0.7))
                    .attr('font-size', '11px')
                    .attr('fill', '#7f8c8d')
                    .text('Overfitting Gap');
                
                g.append('text')
                    .attr('x', xScale(70))
                    .attr('y', yScale(0.95))
                    .attr('font-size', '11px')
                    .attr('fill', '#7f8c8d')
                    .text('Better Generalization');
            }
        }
        
        function initOptimizersViz() {
            const container = d3.select('#optimizers-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 280;
                const margin = {top: 40, right: 40, bottom: 60, left: 60};
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Create scales
                const xScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 2])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 40)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Training Steps');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')
                    .text('Loss ℒ(y, ŷ)');
                
                // Generate optimizer convergence data
                const sgdData = [];
                const momentumData = [];
                const adamData = [];
                
                for (let step = 0; step <= 100; step++) {
                    // SGD: slow, oscillating convergence
                    const sgdLoss = 1.8 * Math.exp(-step * 0.02) + 0.05 + 
                                   0.1 * Math.sin(step * 0.3) * Math.exp(-step * 0.03);
                    sgdData.push({step, loss: sgdLoss});
                    
                    // Momentum: faster, smoother convergence
                    const momentumLoss = 1.8 * Math.exp(-step * 0.04) + 0.03 + 
                                       0.05 * Math.sin(step * 0.2) * Math.exp(-step * 0.05);
                    momentumData.push({step, loss: momentumLoss});
                    
                    // Adam: fast, adaptive convergence
                    const adamLoss = 1.8 * Math.exp(-step * 0.06) + 0.02 + 
                                    0.02 * Math.sin(step * 0.1) * Math.exp(-step * 0.08);
                    adamData.push({step, loss: adamLoss});
                }
                
                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.step))
                    .y(d => yScale(d.loss))
                    .curve(d3.curveBasis);
                
                // Draw optimizer lines
                g.append('path')
                    .datum(sgdData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                g.append('path')
                    .datum(momentumData)
                    .attr('fill', 'none')
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                g.append('path')
                    .datum(adamData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2ecc71')
                    .attr('stroke-width', 3)
                    .attr('d', line);
                
                // Add labels
                g.append('text')
                    .attr('x', xScale(70))
                    .attr('y', yScale(0.4))
                    .attr('fill', '#e74c3c')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('SGD');
                
                g.append('text')
                    .attr('x', xScale(60))
                    .attr('y', yScale(0.2))
                    .attr('fill', '#f39c12')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Momentum');
                
                g.append('text')
                    .attr('x', xScale(50))
                    .attr('y', yScale(0.1))
                    .attr('fill', '#2ecc71')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text('Adam');
                
                // Add title
                g.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .text('Optimizer Comparison: Convergence Speed');
                
                // Add annotations
                g.append('text')
                    .attr('x', xScale(80))
                    .attr('y', yScale(0.7))
                    .attr('font-size', '10px')
                    .attr('fill', '#7f8c8d')
                    .text('Oscillations');
                
                g.append('text')
                    .attr('x', xScale(40))
                    .attr('y', yScale(0.05))
                    .attr('font-size', '10px')
                    .attr('fill', '#7f8c8d')
                    .text('Fastest convergence');
            }
        }
        
        function initializeVisualizationForSlide(slideNumber) {
            try {
                switch (slideNumber) {
                    case 3:
                        initNeuronViz();
                        break;
                    case 4:
                        initNetworkArchitectureViz();
                        break;
                    case 5:
                        initActivationFunctionsViz();
                        break;
                    case 6:
                        initForwardPropagationViz();
                        break;
                    case 7:
                        initLossFunctionsViz();
                        break;
                    case 8:
                        initBackpropagationViz();
                        break;
                    case 9:
                        initTrainingProcessViz();
                        break;
                    case 10:
                        initChallengesViz();
                        break;
                    case 11:
                        initRegularizationViz();
                        break;
                    case 12:
                        initOptimizersViz();
                        break;
                }
            } catch (error) {
                console.error(`Error initializing visualization for slide ${slideNumber}:`, error);
            }
        }
    </script>
</body>
</html>
