<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>t-SNE Algorithm</title>
    
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            overflow: hidden;
        }

        .presentation {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide {
            display: none;
            width: 85vw;
            max-width: 1000px;
            height: 75vh;
            background: white;
            border-radius: 4px;
            padding: 30px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            overflow-y: auto;
            position: absolute;
        }

        .slide.active {
            display: block;
            position: relative;
        }

        /* Typography */
        h1 {
            font-size: 2.2rem;
            font-weight: 300;
            color: #2c3e50;
            margin-bottom: 1.2rem;
            line-height: 1.2;
        }

        h2 {
            font-size: 1.7rem;
            font-weight: 300;
            color: #2c3e50;
            margin-bottom: 1.2rem;
            line-height: 1.3;
        }

        h3 {
            font-size: 1.2rem;
            font-weight: 400;
            color: #34495e;
            margin-bottom: 0.8rem;
        }

        h4 {
            font-size: 1rem;
            font-weight: 500;
            color: #34495e;
            margin-bottom: 0.5rem;
        }

        p {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #5a6c7d;
            margin-bottom: 1rem;
        }

        ul {
            list-style: none;
            margin-bottom: 1rem;
        }

        li {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #5a6c7d;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
            position: relative;
        }

        li::before {
            content: "•";
            color: #3498db;
            position: absolute;
            left: 0;
            font-size: 1.2rem;
        }

        /* Layout classes */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: start;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            align-items: start;
        }

        /* Content blocks */
        .concept-box {
            background: #f8f9fa;
            padding: 1.2rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid #95a5a6;
        }

        .formula-section {
            background: #fdfdfd;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
        }

        .algorithm-box {
            background: #f8f9fa;
            padding: 1.2rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid #3498db;
        }

        /* Title slide styling */
        .title-slide {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .title-slide h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 1.3rem;
            color: #7f8c8d;
            margin-bottom: 2rem;
        }

        .objectives {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .objective {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }

        .objective h3 {
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        /* Evolution timeline */
        .evolution-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 2rem 0;
        }

        .evolution-step {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            flex: 1;
            margin: 0 0.5rem;
            border-left: 4px solid #e67e22;
        }

        .arrow {
            font-size: 1.5rem;
            color: #7f8c8d;
        }

        /* Distribution comparison */
        .distribution-comparison {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 2rem;
            align-items: center;
            margin: 2rem 0;
        }

        .distribution-box {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 4px;
            text-align: center;
            border: 1px solid #bdc3c7;
        }

        .vs-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #34495e;
        }

        /* Parameter grid */
        .parameter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .parameter-box {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            border-left: 4px solid #9b59b6;
        }

        /* Pros and cons layout */
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .pros-box {
            background: #f0fff4;
            padding: 1.5rem;
            border-radius: 4px;
            border-left: 4px solid #27ae60;
        }

        .cons-box {
            background: #fff5f5;
            padding: 1.5rem;
            border-radius: 4px;
            border-left: 4px solid #e74c3c;
        }

        /* Visualization */
        .viz {
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            padding: 0.8rem;
            margin: 0.8rem 0;
            background: white;
            min-height: 250px;
        }

        /* Navigation */
        .counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #34495e;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        .nav-button {
            position: fixed;
            bottom: 20px;
            background: #34495e;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-button:hover {
            background: #2c3e50;
        }

        .prev {
            left: 20px;
        }

        .next {
            left: 80px;
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Title -->
        <div class="slide active title-slide" id="slide1">
            <h1>t-SNE Algorithm</h1>
            <p class="subtitle">t-distributed Stochastic Neighbor Embedding</p>
            
            <div class="objectives">
                <div class="objective">
                    <h3>Probabilistic Foundation</h3>
                    <p>Master conditional probabilities and neighbor distributions</p>
                </div>
                <div class="objective">
                    <h3>Algorithm Mechanics</h3>
                    <p>Understand symmetric SNE and t-distribution innovation</p>
                </div>
                <div class="objective">
                    <h3>Parameter Tuning</h3>
                    <p>Learn perplexity selection and optimization strategies</p>
                </div>
                <div class="objective">
                    <h3>Practical Applications</h3>
                    <p>Apply t-SNE effectively while avoiding common pitfalls</p>
                </div>
            </div>
        </div>

        <!-- Slide 2: The Dimensionality Reduction Problem -->
        <div class="slide" id="slide2">
            <h2>Why t-SNE? The Crowding Problem</h2>
            
            <div class="concept-box">
                <p><strong>The Challenge:</strong> High-dimensional neighborhoods cannot fit in low-dimensional space. Points that are far apart in high dimensions become artificially close in 2D/3D embeddings.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Traditional Methods' Failures</h3>
                    <ul>
                        <li><strong>PCA:</strong> Linear assumptions miss manifold structure</li>
                        <li><strong>MDS:</strong> Preserves all distances, loses local detail</li>
                        <li><strong>Isomap:</strong> Geodesic distances, but still global focus</li>
                        <li><strong>LLE:</strong> Local preservation, but unstable</li>
                    </ul>
                    
                    <h3>The Crowding Problem</h3>
                    <ul>
                        <li>High-D: many points at similar distances</li>
                        <li>Low-D: limited space for all those points</li>
                        <li>Result: distant points crush together</li>
                        <li>Local neighborhoods get destroyed</li>
                    </ul>
                </div>
                
                <div>
                    <div class="viz" id="crowding-viz"></div>
                </div>
            </div>
            
            <div class="concept-box">
                <p><strong>t-SNE's Solution:</strong> Focus on preserving local neighborhoods only. Use probability distributions to handle uncertainty in neighbor relationships.</p>
            </div>
        </div>

        <!-- Slide 3: Evolution from SNE to t-SNE -->
        <div class="slide" id="slide3">
            <h2>From SNE to t-SNE</h2>
            
            <div class="evolution-timeline">
                <div class="evolution-step">
                    <h4>Original SNE</h4>
                    <p>Asymmetric probabilities</p>
                    <p>Difficult optimization</p>
                </div>
                <div class="arrow">→</div>
                <div class="evolution-step">
                    <h4>Symmetric SNE</h4>
                    <p>Simplified gradients</p>
                    <p>Better convergence</p>
                </div>
                <div class="arrow">→</div>
                <div class="evolution-step">
                    <h4>t-SNE</h4>
                    <p>Heavy-tailed distribution</p>
                    <p>Solves crowding problem</p>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Key Innovations</h3>
                    <ul>
                        <li><strong>Probabilistic approach:</strong> Neighbor relationships as probabilities</li>
                        <li><strong>Perplexity:</strong> Effective neighborhood size parameter</li>
                        <li><strong>Symmetric formulation:</strong> Simpler optimization landscape</li>
                        <li><strong>Student-t distribution:</strong> Heavy tails prevent crowding</li>
                    </ul>
                    
                    <div class="algorithm-box">
                        <h4>The t-SNE Insight</h4>
                        <p>Use different probability distributions in high and low dimensions to solve the crowding problem while preserving local structure.</p>
                    </div>
                </div>
                
                <div>
                    <div class="viz" id="evolution-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Mathematical Foundation -->
        <div class="slide" id="slide4">
            <h2>Mathematical Foundation</h2>
            
            <div class="distribution-comparison">
                <div class="distribution-box">
                    <h3>High Dimensions</h3>
                    <p><strong>Gaussian Distribution</strong></p>
                    <p>$$p_{j|i} = \frac{\exp(-||x_i - x_j||^2 / 2\sigma_i^2)}{\sum_{k \neq i} \exp(-||x_i - x_k||^2 / 2\sigma_i^2)}$$</p>
                    <p>Conditional probabilities</p>
                </div>
                
                <div class="vs-text">vs</div>
                
                <div class="distribution-box">
                    <h3>Low Dimensions</h3>
                    <p><strong>Student-t Distribution</strong></p>
                    <p>$$q_{ij} = \frac{(1 + ||y_i - y_j||^2)^{-1}}{\sum_{k \neq l} (1 + ||y_k - y_l||^2)^{-1}}$$</p>
                    <p>Heavy-tailed distribution</p>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Perplexity and Bandwidth</h3>
                    <div class="formula-section">
                        <p>$$\text{Perp}(P_i) = 2^{H(P_i)}$$</p>
                        <p>$$H(P_i) = -\sum_j p_{j|i} \log_2 p_{j|i}$$</p>
                        <p>Effective number of neighbors</p>
                    </div>
                    
                    <h3>Objective Function</h3>
                    <ul>
                        <li>Minimize KL divergence between P and Q</li>
                        <li>$$C = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}$$</li>
                        <li>Symmetric probabilities: $p_{ij} = \frac{p_{j|i} + p_{i|j}}{2n}$</li>
                    </ul>
                </div>
                
                <div>
                    <div class="viz" id="distributions-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 5: The t-SNE Algorithm -->
        <div class="slide" id="slide5">
            <h2>The t-SNE Algorithm</h2>
            
            <div class="grid-2">
                <div>
                    <h3>Algorithm Steps</h3>
                    <div class="algorithm-box">
                        <h4>1. Compute High-D Probabilities</h4>
                        <ul>
                            <li>Calculate pairwise distances</li>
                            <li>Binary search for optimal σᵢ values</li>
                            <li>Ensure target perplexity</li>
                            <li>Symmetrize: $p_{ij} = \frac{p_{j|i} + p_{i|j}}{2n}$</li>
                        </ul>
                        
                        <h4>2. Initialize Low-D Embedding</h4>
                        <ul>
                            <li>Random Gaussian initialization</li>
                            <li>Small variance (σ = 10⁻⁴)</li>
                            <li>Center around origin</li>
                        </ul>
                        
                        <h4>3. Optimize Embedding</h4>
                        <ul>
                            <li>Compute low-D probabilities qᵢⱼ</li>
                            <li>Calculate gradient of KL divergence</li>
                            <li>Update positions with momentum</li>
                            <li>Repeat until convergence</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3>Gradient Computation</h3>
                    <div class="formula-section">
                        <p>$$\frac{\delta C}{\delta y_i} = 4 \sum_j (p_{ij} - q_{ij})(y_i - y_j)(1 + ||y_i - y_j||^2)^{-1}$$</p>
                    </div>
                    
                    <h3>Key Implementation Details</h3>
                    <ul>
                        <li><strong>Early exaggeration:</strong> Multiply P by 4 for first 50 iterations</li>
                        <li><strong>Momentum:</strong> Accelerates convergence, prevents oscillation</li>
                        <li><strong>Learning rate:</strong> Typically 100-1000</li>
                        <li><strong>Iterations:</strong> Usually 1000+ for convergence</li>
                    </ul>
                    
                    <div class="viz" id="algorithm-viz"></div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Key Parameters -->
        <div class="slide" id="slide6">
            <h2>Critical Parameters</h2>
            
            <div class="parameter-grid">
                <div class="parameter-box">
                    <h4>Perplexity (5-50)</h4>
                    <ul>
                        <li><strong>Low values (5-15):</strong> Local structure, tight clusters</li>
                        <li><strong>High values (30-50):</strong> More global awareness</li>
                        <li><strong>Rule of thumb:</strong> 5-50, often 30 works well</li>
                        <li><strong>Dataset dependent:</strong> Larger datasets can use higher values</li>
                    </ul>
                </div>
                
                <div class="parameter-box">
                    <h4>Learning Rate (10-1000)</h4>
                    <ul>
                        <li><strong>Too low:</strong> Slow convergence, local minima</li>
                        <li><strong>Too high:</strong> Unstable optimization, poor quality</li>
                        <li><strong>Typical range:</strong> 100-1000</li>
                        <li><strong>Adaptive:</strong> Some implementations adjust automatically</li>
                    </ul>
                </div>
                
                <div class="parameter-box">
                    <h4>Number of Iterations (1000+)</h4>
                    <ul>
                        <li><strong>Early phase:</strong> Rough positioning (250 iterations)</li>
                        <li><strong>Fine-tuning:</strong> Detailed structure (750+ iterations)</li>
                        <li><strong>Convergence:</strong> Monitor KL divergence decrease</li>
                        <li><strong>Quality vs time:</strong> More iterations = better results</li>
                    </ul>
                </div>
                
                <div class="parameter-box">
                    <h4>Early Exaggeration (4-12)</h4>
                    <ul>
                        <li><strong>Purpose:</strong> Encourage separation of clusters</li>
                        <li><strong>Duration:</strong> First 50-250 iterations</li>
                        <li><strong>Effect:</strong> Clusters move apart, create space</li>
                        <li><strong>Value:</strong> Usually 4, sometimes up to 12</li>
                    </ul>
                </div>
            </div>
            
            <div class="viz" id="parameters-viz"></div>
        </div>

        <!-- Slide 7: Strengths and Applications -->
        <div class="slide" id="slide7">
            <h2>t-SNE Strengths and Applications</h2>
            
            <div class="pros-cons">
                <div class="pros-box">
                    <h3>✓ Strengths</h3>
                    <ul>
                        <li><strong>Exceptional local structure:</strong> Preserves neighborhoods beautifully</li>
                        <li><strong>Cluster revelation:</strong> Makes hidden clusters visible</li>
                        <li><strong>Non-linear manifolds:</strong> Handles complex curved structures</li>
                        <li><strong>Flexible distances:</strong> Works with various similarity metrics</li>
                        <li><strong>Intuitive results:</strong> Often matches human expectations</li>
                    </ul>
                </div>
                
                <div class="cons-box">
                    <h3>✗ Limitations</h3>
                    <ul>
                        <li><strong>No global structure:</strong> Cluster distances meaningless</li>
                        <li><strong>Computational cost:</strong> O(n²) complexity</li>
                        <li><strong>Parameter sensitivity:</strong> Results vary with settings</li>
                        <li><strong>No deterministic results:</strong> Random initialization effects</li>
                        <li><strong>No new point projection:</strong> Must recompute for new data</li>
                    </ul>
                </div>
            </div>
            
            <div class="grid-3">
                <div>
                    <h3>Success Stories</h3>
                    <ul>
                        <li>Single-cell genomics</li>
                        <li>Image dataset exploration</li>
                        <li>Word embedding visualization</li>
                        <li>Document clustering</li>
                        <li>Biological data analysis</li>
                    </ul>
                </div>
                
                <div>
                    <h3>When t-SNE Excels</h3>
                    <ul>
                        <li>Exploratory data analysis</li>
                        <li>Cluster discovery</li>
                        <li>Pattern visualization</li>
                        <li>Quality assessment</li>
                        <li>Presentation purposes</li>
                    </ul>
                </div>
                
                <div>
                    <h3>When to Avoid</h3>
                    <ul>
                        <li>Need global distance preservation</li>
                        <li>Very large datasets (>10k points)</li>
                        <li>Streaming/online scenarios</li>
                        <li>Quantitative analysis</li>
                        <li>Production ML pipelines</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 8: Implementation and Scalability -->
        <div class="slide" id="slide8">
            <h2>Implementation Challenges</h2>
            
            <div class="concept-box">
                <p><strong>Computational Reality:</strong> Standard t-SNE has O(n²) complexity in both time and memory, making it impractical for large datasets without approximations.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Computational Bottlenecks</h3>
                    <ul>
                        <li><strong>Distance computation:</strong> O(n²) pairwise distances</li>
                        <li><strong>Probability calculation:</strong> Expensive normalization</li>
                        <li><strong>Gradient computation:</strong> All-pairs interactions</li>
                        <li><strong>Memory requirements:</strong> Store n×n probability matrices</li>
                    </ul>
                    
                    <h3>Barnes-Hut Approximation</h3>
                    <ul>
                        <li><strong>Idea:</strong> Approximate distant point interactions</li>
                        <li><strong>Tree structure:</strong> Hierarchical space partitioning</li>
                        <li><strong>Complexity:</strong> O(n log n) instead of O(n²)</li>
                        <li><strong>Trade-off:</strong> Speed vs accuracy</li>
                    </ul>
                </div>
                
                <div>
                    <h3>Practical Guidelines</h3>
                    <ul>
                        <li><strong>Dataset size:</strong> Standard t-SNE up to ~10k points</li>
                        <li><strong>Barnes-Hut:</strong> Up to ~100k points</li>
                        <li><strong>Preprocessing:</strong> PCA to 50 dimensions first</li>
                        <li><strong>Sampling:</strong> Use subset for exploration</li>
                    </ul>
                    
                    <div class="algorithm-box">
                        <h4>Modern Alternatives</h4>
                        <ul>
                            <li><strong>UMAP:</strong> Faster, preserves more global structure</li>
                            <li><strong>FIt-SNE:</strong> Faster t-SNE implementation</li>
                            <li><strong>Multicore-TSNE:</strong> Parallel processing</li>
                            <li><strong>openTSNE:</strong> Modern, optimized implementation</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="viz" id="scalability-viz"></div>
        </div>

        <!-- Slide 9: Common Pitfalls and Best Practices -->
        <div class="slide" id="slide9">
            <h2>Avoiding Common Pitfalls</h2>
            
            <div class="grid-2">
                <div>
                    <h3>Interpretation Mistakes</h3>
                    <ul>
                        <li><strong>Distance fallacy:</strong> Cluster distances are meaningless</li>
                        <li><strong>Size interpretation:</strong> Cluster sizes don't reflect data density</li>
                        <li><strong>Isolated points:</strong> May be artifacts, not real outliers</li>
                        <li><strong>Multiple runs:</strong> Different results don't mean errors</li>
                    </ul>
                    
                    <h3>Parameter Pitfalls</h3>
                    <ul>
                        <li><strong>Wrong perplexity:</strong> Too low = fragmented clusters</li>
                        <li><strong>Insufficient iterations:</strong> Premature stopping</li>
                        <li><strong>Poor learning rate:</strong> Unstable or slow optimization</li>
                        <li><strong>No preprocessing:</strong> Scaling issues with raw data</li>
                    </ul>
                </div>
                
                <div>
                    <h3>Best Practices</h3>
                    <div class="algorithm-box">
                        <h4>Data Preparation</h4>
                        <ul>
                            <li>Standardize features (zero mean, unit variance)</li>
                            <li>Remove or handle missing values</li>
                            <li>Consider PCA preprocessing for very high dimensions</li>
                            <li>Remove duplicates and near-duplicates</li>
                        </ul>
                        
                        <h4>Parameter Selection</h4>
                        <ul>
                            <li>Try multiple perplexity values (10, 30, 50)</li>
                            <li>Run multiple times with different seeds</li>
                            <li>Monitor convergence (KL divergence)</li>
                            <li>Use early exaggeration appropriately</li>
                        </ul>
                        
                        <h4>Validation</h4>
                        <ul>
                            <li>Compare with known structure</li>
                            <li>Test with different parameters</li>
                            <li>Validate clusters with domain knowledge</li>
                            <li>Use quantitative metrics when possible</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 10: Key Takeaways -->
        <div class="slide" id="slide10">
            <h2>Key Takeaways</h2>
            
            <div class="concept-box">
                <p><strong>t-SNE's Legacy:</strong> Revolutionized data visualization by solving the crowding problem through probabilistic neighborhood preservation and heavy-tailed distributions.</p>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Core Insights</h3>
                    <ul>
                        <li><strong>Local focus:</strong> Prioritize neighborhood preservation over global distances</li>
                        <li><strong>Probabilistic approach:</strong> Handle uncertainty in neighbor relationships</li>
                        <li><strong>Heavy-tailed solution:</strong> Student-t distribution prevents crowding</li>
                        <li><strong>Parameter sensitivity:</strong> Perplexity critically affects results</li>
                    </ul>
                    
                    <h3>When to Use t-SNE</h3>
                    <ul>
                        <li>Exploratory data analysis and visualization</li>
                        <li>Cluster discovery in high-dimensional data</li>
                        <li>Pattern recognition and anomaly detection</li>
                        <li>Quality assessment of embeddings</li>
                        <li>Presentation and communication purposes</li>
                    </ul>
                </div>
                
                <div>
                    <h3>Limitations to Remember</h3>
                    <ul>
                        <li><strong>Global structure loss:</strong> Cluster distances meaningless</li>
                        <li><strong>Computational complexity:</strong> Doesn't scale to very large data</li>
                        <li><strong>Stochastic results:</strong> Different runs give different outputs</li>
                        <li><strong>No out-of-sample:</strong> Can't project new points easily</li>
                    </ul>
                    
                    <h3>Modern Context</h3>
                    <ul>
                        <li>Still excellent for small-medium datasets</li>
                        <li>UMAP often preferred for larger datasets</li>
                        <li>Remains gold standard for local structure</li>
                        <li>Essential tool in data scientist toolkit</li>
                        <li>Continues to inspire new methods</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="counter">
        <span id="current">1</span> / <span id="total">10</span>
    </div>

    <script>
        let currentSlide = 1;
        const totalSlides = 10;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            if (n > totalSlides) currentSlide = 1;
            if (n < 1) currentSlide = totalSlides;
            
            slides.forEach(slide => slide.classList.remove('active'));
            document.getElementById(`slide${currentSlide}`).classList.add('active');
            document.getElementById('current').textContent = currentSlide;
        }

        function nextSlide() {
            currentSlide++;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide--;
            showSlide(currentSlide);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                prevSlide();
            }
        });

        // Initialize
        showSlide(currentSlide);

        // D3.js Visualizations
        function initCrowdingViz() {
            const container = d3.select('#crowding-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 220;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // High-dimensional space (represented as distances)
                const leftG = svg.append('g')
                    .attr('transform', 'translate(40, 20)');
                
                leftG.append('text')
                    .attr('x', 60).attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('High-Dimensional Space');
                
                // Show distance distribution
                const distances = [2, 2.1, 2.2, 2.15, 2.3, 2.25, 2.05, 2.4];
                const center = {x: 60, y: 100};
                
                distances.forEach((dist, i) => {
                    const angle = (i / distances.length) * 2 * Math.PI;
                    const x = center.x + dist * 15 * Math.cos(angle);
                    const y = center.y + dist * 15 * Math.sin(angle);
                    
                    leftG.append('line')
                        .attr('x1', center.x)
                        .attr('y1', center.y)
                        .attr('x2', x)
                        .attr('y2', y)
                        .attr('stroke', '#bdc3c7')
                        .attr('stroke-width', 1);
                    
                    leftG.append('circle')
                        .attr('cx', x)
                        .attr('cy', y)
                        .attr('r', 3)
                        .attr('fill', '#3498db')
                        .attr('opacity', 0.7);
                    
                    // Distance labels
                    leftG.append('text')
                        .attr('x', x + 10)
                        .attr('y', y)
                        .style('font-size', '8px')
                        .text(dist.toFixed(1));
                });
                
                leftG.append('circle')
                    .attr('cx', center.x)
                    .attr('cy', center.y)
                    .attr('r', 4)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2);
                
                leftG.append('text')
                    .attr('x', 60)
                    .attr('y', 180)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text('All neighbors at similar distances');
                
                // Arrow
                svg.append('path')
                    .attr('d', `M${width/2 - 30},100 L${width/2 + 10},100 M${width/2 + 5},95 L${width/2 + 10},100 L${width/2 + 5},105`)
                    .attr('stroke', '#7f8c8d')
                    .attr('stroke-width', 2)
                    .attr('fill', 'none');
                
                // Low-dimensional crowding
                const rightG = svg.append('g')
                    .attr('transform', `translate(${width - 140}, 20)`);
                
                rightG.append('text')
                    .attr('x', 60).attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('2D Embedding');
                
                // Crowded points
                const center2D = {x: 60, y: 100};
                Array.from({length: 8}, (_, i) => {
                    const angle = (i / 8) * 2 * Math.PI;
                    const radius = 15 + Math.random() * 10;
                    return {
                        x: center2D.x + radius * Math.cos(angle),
                        y: center2D.y + radius * Math.sin(angle)
                    };
                }).forEach(point => {
                    rightG.append('circle')
                        .attr('cx', point.x)
                        .attr('cy', point.y)
                        .attr('r', 3)
                        .attr('fill', '#3498db')
                        .attr('opacity', 0.7);
                });
                
                rightG.append('circle')
                    .attr('cx', center2D.x)
                    .attr('cy', center2D.y)
                    .attr('r', 4)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2);
                
                rightG.append('text')
                    .attr('x', 60)
                    .attr('y', 180)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text('Points forced too close together');
            }
        }

        function initEvolutionViz() {
            const container = d3.select('#evolution-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 180;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Show the key insight: heavy-tailed distribution
                const g = svg.append('g')
                    .attr('transform', 'translate(20, 20)');
                
                g.append('text')
                    .attr('x', width/2 - 20)
                    .attr('y', 20)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .text('Key Insight: Heavy-Tailed Distribution');
                
                // Draw Gaussian vs t-distribution curves
                const xScale = d3.scaleLinear()
                    .domain([-3, 3])
                    .range([20, width - 40]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 0.5])
                    .range([140, 40]);
                
                // Gaussian curve
                const gaussianData = [];
                for (let x = -3; x <= 3; x += 0.1) {
                    const y = Math.exp(-x * x / 2) / Math.sqrt(2 * Math.PI);
                    gaussianData.push({x, y});
                }
                
                const gaussianLine = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveCardinal);
                
                g.append('path')
                    .datum(gaussianData)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 2)
                    .attr('d', gaussianLine);
                
                // t-distribution curve (heavier tails)
                const tData = [];
                for (let x = -3; x <= 3; x += 0.1) {
                    const y = 1 / (Math.PI * (1 + x * x)); // Simplified t-distribution
                    tData.push({x, y: y * 0.8}); // Scale for visibility
                }
                
                const tLine = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveCardinal);
                
                g.append('path')
                    .datum(tData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e67e22')
                    .attr('stroke-width', 2)
                    .attr('d', tLine);
                
                // Labels
                g.append('text')
                    .attr('x', width - 80)
                    .attr('y', 60)
                    .style('font-size', '11px')
                    .style('fill', '#3498db')
                    .text('Gaussian (High-D)');
                
                g.append('text')
                    .attr('x', width - 80)
                    .attr('y', 80)
                    .style('font-size', '11px')
                    .style('fill', '#e67e22')
                    .text('Student-t (Low-D)');
                
                g.append('text')
                    .attr('x', width/2 - 20)
                    .attr('y', 155)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text('Heavy tails allow distant points to repel moderately');
            }
        }

        function initDistributionsViz() {
            const container = d3.select('#distributions-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 200;
                const margin = {top: 20, right: 20, bottom: 40, left: 40};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Show perplexity effect
                const perplexities = [5, 15, 30, 50];
                const colors = ['#e74c3c', '#f39c12', '#3498db', '#27ae60'];
                
                const xScale = d3.scaleLinear()
                    .domain([0, 4])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale).tickFormat((d, i) => perplexities[i] || ''))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 35)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Perplexity');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -25)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Effective Neighbors');
                
                // Show neighborhood sizes
                const neighborhoodSizes = [0.2, 0.5, 0.8, 0.95];
                
                perplexities.forEach((perp, i) => {
                    g.append('rect')
                        .attr('x', xScale(i) - 10)
                        .attr('y', yScale(neighborhoodSizes[i]))
                        .attr('width', 20)
                        .attr('height', innerHeight - yScale(neighborhoodSizes[i]))
                        .attr('fill', colors[i])
                        .attr('opacity', 0.7);
                    
                    g.append('text')
                        .attr('x', xScale(i))
                        .attr('y', yScale(neighborhoodSizes[i]) - 5)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .text(perp);
                });
            }
        }

        function initAlgorithmViz() {
            const container = d3.select('#algorithm-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 160;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Show optimization process
                let iteration = 0;
                const maxIterations = 100;
                
                // Initial random layout
                const points = Array.from({length: 15}, (_, i) => ({
                    id: i,
                    x: Math.random() * width,
                    y: Math.random() * height,
                    targetX: (i % 3) * (width / 3) + width / 6 + (Math.random() - 0.5) * 20,
                    targetY: Math.floor(i / 3) * (height / 5) + height / 6 + (Math.random() - 0.5) * 20,
                    cluster: Math.floor(i / 5)
                }));
                
                function animate() {
                    svg.selectAll('*').remove();
                    
                    const t = iteration / maxIterations;
                    const lr = Math.max(0.1, 1.0 - t); // Learning rate decay
                    
                    points.forEach(point => {
                        // Move towards target with momentum
                        const dx = point.targetX - point.x;
                        const dy = point.targetY - point.y;
                        point.x += dx * lr * 0.1;
                        point.y += dy * lr * 0.1;
                    });
                    
                    // Draw points
                    const colors = ['#3498db', '#e67e22', '#27ae60'];
                    svg.selectAll('.point')
                        .data(points)
                        .enter().append('circle')
                        .attr('class', 'point')
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y)
                        .attr('r', 3)
                        .attr('fill', d => colors[d.cluster])
                        .attr('opacity', 0.8);
                    
                    svg.append('text')
                        .attr('x', 10).attr('y', 20)
                        .style('font-size', '12px')
                        .text(`Iteration: ${iteration} (LR: ${lr.toFixed(2)})`);
                    
                    iteration = (iteration + 1) % (maxIterations + 20);
                    
                    if (iteration === 0) {
                        // Reset to random positions
                        points.forEach(point => {
                            point.x = Math.random() * width;
                            point.y = Math.random() * height;
                        });
                    }
                }
                
                const interval = setInterval(animate, 80);
                
                // Clean up on slide change
                setTimeout(() => clearInterval(interval), 8000);
            }
        }

        function initParametersViz() {
            const container = d3.select('#parameters-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 120;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Show effect of different perplexity values
                const scenarios = [
                    {name: 'Perplexity=5', x: 100, tightness: 0.3},
                    {name: 'Perplexity=30', x: 300, tightness: 0.6},
                    {name: 'Perplexity=50', x: 500, tightness: 0.8}
                ];
                
                scenarios.forEach(scenario => {
                    const g = svg.append('g')
                        .attr('transform', `translate(${scenario.x - 60}, 20)`);
                    
                    g.append('text')
                        .attr('x', 60).attr('y', 15)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '11px')
                        .style('font-weight', 'bold')
                        .text(scenario.name);
                    
                    // Generate clusters with different connectivity
                    const clusters = [
                        {center: {x: 30, y: 50}, color: '#3498db'},
                        {center: {x: 90, y: 50}, color: '#e67e22'}
                    ];
                    
                    clusters.forEach(cluster => {
                        Array.from({length: 6}, () => {
                            const spread = 15 * (1 - scenario.tightness);
                            const angle = Math.random() * 2 * Math.PI;
                            const radius = Math.random() * spread;
                            return {
                                x: cluster.center.x + radius * Math.cos(angle),
                                y: cluster.center.y + radius * Math.sin(angle) + 25,
                                color: cluster.color
                            };
                        }).forEach(point => {
                            g.append('circle')
                                .attr('cx', point.x)
                                .attr('cy', point.y)
                                .attr('r', 2.5)
                                .attr('fill', point.color)
                                .attr('opacity', 0.7);
                        });
                    });
                });
                
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height - 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text('Higher perplexity → broader neighborhood awareness');
            }
        }

        function initScalabilityViz() {
            const container = d3.select('#scalability-viz');
            if (!container.empty()) {
                container.html('');
                
                const width = container.node().getBoundingClientRect().width;
                const height = 180;
                const margin = {top: 20, right: 40, bottom: 40, left: 60};
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Show computational complexity
                const dataPoints = [100, 500, 1000, 5000, 10000, 50000];
                const standardTimes = dataPoints.map(n => Math.pow(n/1000, 2) * 10); // O(n²)
                const barnesHutTimes = dataPoints.map(n => (n/1000) * Math.log(n/1000) * 3); // O(n log n)
                
                const xScale = d3.scaleLog()
                    .domain([100, 50000])
                    .range([0, innerWidth]);
                
                const yScale = d3.scaleLog()
                    .domain([1, 2500])
                    .range([innerHeight, 0]);
                
                // Add axes
                g.append('g')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.format('d')))
                    .append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', 35)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Dataset Size');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -40)
                    .attr('x', -innerHeight / 2)
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text('Time (minutes)');
                
                // Standard t-SNE line
                const standardLine = d3.line()
                    .x((d, i) => xScale(dataPoints[i]))
                    .y(d => yScale(d))
                    .curve(d3.curveMonotoneX);
                
                g.append('path')
                    .datum(standardTimes)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('d', standardLine);
                
                // Barnes-Hut line
                const barnesHutLine = d3.line()
                    .x((d, i) => xScale(dataPoints[i]))
                    .y(d => yScale(d))
                    .curve(d3.curveMonotoneX);
                
                g.append('path')
                    .datum(barnesHutTimes)
                    .attr('fill', 'none')
                    .attr('stroke', '#27ae60')
                    .attr('stroke-width', 2)
                    .attr('d', barnesHutLine);
                
                // Legend
                const legend = g.append('g')
                    .attr('transform', `translate(${innerWidth - 120}, 20)`);
                
                legend.append('line')
                    .attr('x1', 0).attr('x2', 20)
                    .attr('y1', 0).attr('y2', 0)
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2);
                
                legend.append('text')
                    .attr('x', 25).attr('y', 4)
                    .style('font-size', '11px')
                    .text('Standard t-SNE');
                
                legend.append('line')
                    .attr('x1', 0).attr('x2', 20)
                    .attr('y1', 15).attr('y2', 15)
                    .attr('stroke', '#27ae60')
                    .attr('stroke-width', 2);
                
                legend.append('text')
                    .attr('x', 25).attr('y', 19)
                    .style('font-size', '11px')
                    .text('Barnes-Hut');
            }
        }

        // Initialize visualizations when slides are shown
        const originalShowSlide = showSlide;
        showSlide = function(n) {
            originalShowSlide(n);
            
            // Initialize visualizations based on current slide
            setTimeout(() => {
                if (currentSlide === 2) initCrowdingViz();
                if (currentSlide === 3) initEvolutionViz();
                if (currentSlide === 4) initDistributionsViz();
                if (currentSlide === 5) initAlgorithmViz();
                if (currentSlide === 6) initParametersViz();
                if (currentSlide === 8) initScalabilityViz();
            }, 100);
        };

        // Initialize current slide visualizations
        setTimeout(() => {
            if (currentSlide === 2) initCrowdingViz();
            if (currentSlide === 3) initEvolutionViz();
            if (currentSlide === 4) initDistributionsViz();
            if (currentSlide === 5) initAlgorithmViz();
            if (currentSlide === 6) initParametersViz();
            if (currentSlide === 8) initScalabilityViz();
        }, 100);
    </script>
</body>
</html>
